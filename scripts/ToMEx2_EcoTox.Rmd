---
title: "EcoTox - ToMEx 2"
author: "Scott Coffin"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: journal
    toc: yes
    toc_float: yes
    toc_depth: 6
    number_sections: true
  word_document:
    toc: yes
---
#Setup

```{r, setup, include=FALSE}
#knitr::opts_knit$set(root.dir = "G:/My Drive/MooreInstitute/Projects/ToMEx2.0_EcoToxRisk")
```

```{r, include=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=8, fig.path='output/figures',
                      warning=FALSE, message=FALSE,time_it = TRUE) 
```

## Libraries
```{r Libraries, include = FALSE}
library(tidyverse)
library(calecopal)
library(ssdtools)
library(DT)
library(plotly)
library(gridExtra)
library(grid)
library(wesanderson)
library(ggdark)
library(broom)
library(knitr)
library(kableExtra)
library(viridis)
library(ggrepel)
library(scales)
library(gt)
library(ggsci)
library(openxlsx)
library(ggpubr)
library(psych) # To use the geometric.mean function
library(Matrix)
library(mc2d)
library(trapezoid)
library(reshape2)
getwd()

```

```{r Set Particle Size, include = FALSE}
###define sizes for filtering and alignment##
# smaller size bin
small_tier_lower_size <- 1 #um
small_tier_upper_size <- 5000 #um #size to align to
upper.tissue.trans.size.um <- 88 #um #set size for filtering data and x2M
# larger size bin
large_tier_lower_size <- 1 #um
large_tier_upper_size <- 5000 #um

nboot = 100 #number of bootstrap iterations for the traditional SSD (keep at 10 for beta testing, but use 1000 for final)
```

```{r Aesthetics, include = FALSE}
#Theme
theme.type <- dark_theme_bw(base_size = 15) +
  #theme_bw(base_size = 15) +
              theme(plot.title = element_text(hjust = 0.5),
                    plot.subtitle = element_text(hjust = 0.5))

#Fill
fill.type <-  scale_fill_nejm()

#Color
color.type <- scale_color_nejm()

#ggplot themes
theme.light <- theme_minimal(base_size = 15) +
  theme(legend.position = c(0.2, 0.85),
        legend.title = element_text(size = 16, face = "bold"),
        legend.text = element_text(size = 14),
        legend.title.align = 0.5,
        legend.text.align = 0.5,
     #   legend.box.background = element_rect(color = "black", linetype =
      #                                         "solid", size = 1),
  #legend.background = element_rect(fill = "gray90", size = 0.5, linetype =
                   #                  "solid"),  # Light gray background forlegend
        plot.title = element_text(hjust = 0.5),     # Center the main title
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption = element_text(hjust = 0.5),   # Center the caption
        axis.title.x = element_text(hjust = 0.5, size = 18),  # Center the x-axis title
        axis.text = element_text(size = 16),
        axis.title.y = element_text(vjust = 0.5, size = 18))   # Center the y-axis title (vertically))   # Center the subtitle)

theme.dark <- dark_theme_minimal(base_size = 15) +
  theme(legend.position = c(0.2, 0.85),
        legend.title = element_text(size = 16, face = "bold"),
        legend.text = element_text(size = 14),
        legend.title.align = 0.5,
        legend.text.align = 0.5,
     #   legend.box.background = element_rect(color = "black", linetype =
      #                                         "solid", size = 1),
  #legend.background = element_rect(fill = "gray90", size = 0.5, linetype =
                   #                  "solid"),  # Light gray background forlegend
        plot.title = element_text(hjust = 0.5),     # Center the main title
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption = element_text(hjust = 0.5),   # Center the caption
        axis.title.x = element_text(hjust = 0.5, size = 18),  # Center the x-axis title
        axis.text = element_text(size = 16),
        axis.title.y = element_text(vjust = 0.5, size = 18))   # Center the y-axis title (vertically))   # Center the subtitle)
```


### Data Import
```{r Data Import, include = FALSE}
#Load aoc_z into dataframe. This file is generated from aq_mp_tox_shiny repo / ToMEx2.0_Onboarding / ToMEx2.0_Data_Tidying.R

#aoc_z <- readRDS(file = "G:/My Drive/MooreInstitute/Projects/ToMEx2.0_EcoToxRisk/data/input/aoc_z_tomex2.RDS") %>% 
  #rename columns so they fir the OG script
getwd()

aoc_z <- readRDS("../data/input/aoc_z_tomex2.RDS") %>%  #dataset is prepped in shiny repo
  rename(environment = env_f)# %>% 
  #select(-rowid)# %>% #existing rowid is actually replicated (not sure how)
  #mutate(rowid = row_number())

#aoc_z$rowid <- sapply(seq_len(nrow(aoc_z)), function(x) uuid::UUIDgenerate())
```

### Data Cleanup
A large number of values is getting filtered out during alignments. This should not be the case. We can debug by looking at missing values for the parameters that are relevant to alignments.
```{r}
aoc_simple <- aoc_z %>%
   filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
         exp_type_f == "Particle Only",
         tier_zero_tech_f == "Red Criteria Passed",
         tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) %>% 
  ungroup()# %>% 
  #select(c(rowid, max.size.ingest.mm, dose.particles.mL.master, particle.surface.area.um2,
         #  particle.surface.area.um2.min, particle.surface.area.um2.max, polydispersity)) 

# for polydisperse data, we need the particle.surface.area.um2.min and max to be filled out. For monodisperse data, just the particle.surface.area.um2 is needed.

aoc_simple_check <- aoc_simple %>% 
   mutate(data_available = case_when(
    # Condition for polydisperse: particle.surface.area.um2.min and .max cannot be NA
    polydispersity == "polydisperse" & !is.na(particle.surface.area.um2.min) & !is.na(particle.surface.area.um2.max) ~ TRUE,
    # Condition for monodisperse: particle.surface.area.um2 cannot be NA
    polydispersity == "monodisperse" & !is.na(particle.surface.area.um2) ~ TRUE,
    # Otherwise, data is not available according to the criteria
    TRUE ~ FALSE
  )) %>% 
  drop_na(dose.particles.mL.master)

aoc_simple_check %>% 
  filter(!data_available)
```

## Summary Statistics
```{r}
## how many studies/data points/species exist in starting and final databases?
aoc_z %>%
  mutate(
    data_available = case_when(
      # Condition for polydisperse: particle.surface.area.um2.min and .max cannot be NA
      polydispersity == "polydisperse" &
        !is.na(particle.surface.area.um2.min) &
        !is.na(particle.surface.area.um2.max) ~ TRUE,
      # Condition for monodisperse: particle.surface.area.um2 cannot be NA
      polydispersity == "monodisperse" &
        !is.na(particle.surface.area.um2) ~ TRUE,
      # Otherwise, data is not available according to the criteria
      TRUE ~ FALSE
    )
  ) %>%
  mutate(
    thresholds1_2 = case_when(
      data_available == TRUE &
        !environment %in% c("Terrestrial", "Not Reported") &
        Group != "Bacterium" &
        Group != "Plant" &
        effect.metric != "HONEC" &
        !is.na(effect.metric) &
        exp_type_f == "Particle Only" &
        tier_zero_tech_f == "Red Criteria Passed" &
        tier_zero_risk_f == "Red Criteria Passed" & # All thresholds must pass technical and risk red criteria
        risk.13 != 0 ~ TRUE,
      # Otherwise, do not meet thresholds1_2 criteria
      TRUE ~ FALSE
    )
  ) %>%
  mutate(
    thresholds3_4 = case_when(
      thresholds1_2 == TRUE &
        risk.13 != 1 &
        bio_f %in% c("Organism", "Population") 
    ~ TRUE,
      # Otherwise, do not meet thresholds3_4 criteria
      TRUE ~ FALSE
    )
  ) %>%
   pivot_longer(
    cols = c(thresholds1_2, thresholds3_4),
    names_to = "threshold",
    values_to = "value"
  ) %>%
  group_by(threshold, value
           , environment
           ) %>%
  #group_by(thresholds1_2, thresholds3_4) %>%
  summarise(
    n_species = n_distinct(Species),
    n_studies = n_distinct(doi),
    n_datapoint = n()
  )


```


#Framework Summary

![Agreed-upon framework](../assets/threshold_framework.png)

The figure above displays the working threshold framework for the ambient threshold group for the Microplastics Health Effects Workshop. 

The current framework for generating SSDs includes the following parameters:

Data pertaining to only aquatic organisms are included (marine and freshwater).  

All taxa are included with the exception of bacterium and plants.  

HONEC (Highest Observed No Effect Concentration) are excluded.  

Assessment factors are applied to convert all other effect metrics into NOECs:

![](../assets/AF_EM.png)

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)  

Assessment factors are applied to convert acute data into chronic:  

![](../assets/AF_chronic.png)

Green rows are from Wigger et al. 2020. Grey rows were agreed upon by the ambient threshold working group.

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)

Note: Values may be slightly different than those presented in the shiny app as concentrations are converted from particles/mL to particles/L ahead of calculations.


# ERM/SSD Calculations
The following script utilizes the above equations to calculate *a priori* effect thresholds for each of the ERM of interest for each species in the database, then calculates species sensitivity distributions using each ERM.

*Data Filtering by Quality*
```{r}
## First filter data with global filters
aoc_intermediate <- aoc_z %>% 
   ### quality score filters applied below for thresholds ###
  # filter(!environment %in% c("Terrestrial", "Not Reported"),
  #        Group != "Bacterium",
  #        Group != "Plant",
  #        effect.metric != "HONEC",
  #        tier_zero_tech_f == "Red Criteria Passed",
  #        tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
  #        risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
  #        ) %>% 
  #Remove 26C temperature treatment data from Jaimukar et al. 2018
  filter(!(article == 42 & media.temp == 26)) %>% 
  mutate(max.size.ingest.um = 1000 * max.size.ingest.mm) #makes it less confusing below

### NEED TO DETERMINE FILTERING PROTOCOL FOR CASES IN WHICH SPECIES HAVE MANY LOECS OR NOECS FOR SAME DOSE FOR SLIGHTLY SIMILIAR ENDPOINTS - E.G., MYTILUS GALLOPROVENCIALIS ###


#### Ecologically Relevant Metric calculations ####

#examine available data as histogram
Group_size <- aoc_intermediate %>% 
  ggplot(aes(x = size.length.um.used.for.conversions, fill = Group)) +
  geom_histogram(bins = 25) +
  scale_fill_manual(values = cal_palette(name = "superbloom1", type = "continuous", n = 15)) +
  labs(title = "Filtered Data by Group") +
  ylab("# of observations")+
  xlab("Length (um)") +
  theme.type +
  scale_x_log10()

endpoint_size <- aoc_intermediate %>% 
  ggplot(aes(x = size.length.um.used.for.conversions, fill = lvl1_f)) +
  geom_histogram(bins = 25) +
   scale_fill_manual(name = "General Endpoint", values = cal_palette(name = "superbloom3", type = "continuous", n = 15)) +
  xlab("Particle Length (um)") +
  ylab("# of observations")+
  labs(title = "Filtered Data by General Endpoint") +
  theme.type +
  scale_x_log10()

#arrange histograms
grid.arrange(Group_size, endpoint_size)
```

### Alignment

#### Parameters
```{r}
R.ave.water.marine <- 0.77 # average length to width ratio of microplastics in marine environment (Kooi et al. 2021)
R.ave.water.freshwater <- 0.67 # average length to width ratio of microplastics in freshwater environment (Kooi et al. 2021)
R.ave.sediment.marine <- 0.75 # average length to width ratio of microplastics in marine environment (Kooi et al. 2021)
R.ave.sediment.freshwater <- 0.70 # average length to width ratio of microplastics in freshwater environment (Kooi et al. 2021)
p.ave.marine = 1.10 #average density in marine surface water
alpha.marine = 2.07 #table s4 for marine surface water. length
a.sa.marine = 1.50 #marine surface area power law
a.v.marine = 1.48 #a_V for marine surface water volume
a.m.marine = 1.32 # upper limit fora_m for mass for marine surface water in table S4 
a.ssa.marine = 1.98 # A_SSA for marine surface water
p.ave.freshwater = 1.04 #average density in freshwater surface water
alpha.freshwater = 2.64 #table s4 for freshwater surface water. length
a.sa.freshwater = 2.00 #freshwater surface area power law
a.v.freshwater = 1.68 #a_V for freshwater surface water volume
a.m.freshwater = 1.65 # upper limit fora_m for mass for freshwater surface water in table S4 
a.ssa.freshwater = 2.71 # A_SSA for freshwater surface water

#join alpha values for each data point
aoc_intermediate_alphas <- aoc_intermediate %>% 
   # define environment-specific alpha parameters #
    mutate(alpha = case_when(environment == "Marine" ~ alpha.marine,
                             environment == "Freshwater" ~ alpha.freshwater),
           a.sa = case_when(environment == "Marine" ~ a.sa.marine,
                            environment == "Freshwater" ~ a.sa.freshwater),
           a.v = case_when(environment == "Marine" ~ a.v.marine,
                            environment == "Freshwater" ~ a.v.freshwater),
           a.m = case_when(environment == "Marine" ~ a.m.marine,
                           environment == "Freshwater" ~ a.m.freshwater),
           a.ssa = case_when(environment == "Marine" ~ a.ssa.marine,
                           environment == "Freshwater" ~ a.ssa.freshwater),
           R.ave = case_when(environment == "Marine" ~ R.ave.water.marine,
                             environment == "Freshwater" ~ R.ave.water.freshwater),
           p.ave = case_when(environment == "Marine" ~ p.ave.marine,
                             environment == "Freshwater" ~ p.ave.freshwater)
           )
```

#### Functions
```{r}
###function to derive correction factor (CF) from Koelmans et al (equation 2)
CFfnx = function(a, #default alpha from Koelmans et al (2020)
                 x2D, #set detault values to convert ranges to (1-5,000 um) #5mm is upper defuault 
                 x1D, #1 um is lower default size
                 x2M, x1M){
  CF = (x2D^(1-a)-x1D^(1-a))/(x2M^(1-a)-x1M^(1-a)) 
  return(CF)}

#### equations for mu_x_poly (note that there are three depending on certain alphas for limits of equation)
mux_polyfnx_generalizable <- function(a.x, x_UL, x_LL) {
  # Create a result vector of the same length as the input
  mux.poly <- numeric(length(a.x))
  
  # Case when a.x == 1
  idx1 <- which(a.x == 1)
  mux.poly[idx1] <- (x_UL[idx1] - x_LL[idx1]) / (log(x_UL[idx1] / x_LL[idx1]))
  
  # Case when a.x == 2
  idx2 <- which(a.x == 2)
  mux.poly[idx2] <- (log(x_UL[idx2] / x_LL[idx2])) / (x_LL[idx2]^-1 - x_UL[idx2]^-1)
  
  # Case for other values of a.x
  idx_else <- which(!(a.x == 1 | a.x == 2))
  mux.poly[idx_else] <- ((1 - a.x[idx_else]) / (2 - a.x[idx_else])) * 
    ((x_UL[idx_else]^(2 - a.x[idx_else]) - x_LL[idx_else]^(2 - a.x[idx_else])) / 
     (x_UL[idx_else]^(1 - a.x[idx_else]) - x_LL[idx_else]^(1 - a.x[idx_else])))
  
  return(mux.poly)
}



# #generalizable if a.x =2 or not
# mux.polyfnx_generalizable = Vectorize(function(a.x, x_UL, x_LL){
#   if(a.x == 1){ # in case a.x = 1
#     mux.poly = (x_UL - x_LL)/(log(x_UL/x_LL))
#     return(mux.poly)}
#   if(a.x == 2){ # in case a.x = 2
#      mux.poly = (log10(x_UL/x_LL))/(x_LL^(-1) - x_UL^-1)
#      return(mux.poly)}
#   else{ #in case alpha is not 2 or 1
#     mux.poly = ((1-a.x)/(2-a.x)) * ((x_UL^(2-a.x) - x_LL^(2-a.x))/(x_UL^(1-a.x) - x_LL^(1-a.x)))
#     return(mux.poly)}
#   },
#   vectorize.args = "a.x") # if Vectorize isn't here, the if else won't work
# ## ^^ Note that the above generalizable function doesn't play well with mutate(case_when), likely due to some bug with dplyr. I don't have a solution to this, so a special equation will need to be used when those values are used...
# 
# #in case alpha is not 1 or 2
# mux.polyfnx = function(a.x, x_UL, x_LL){
#     mux.poly = ((1-a.x)/(2-a.x)) * ((x_UL^(2-a.x) - x_LL^(2-a.x))/(x_UL^(1-a.x) - x_LL^(1-a.x)))
#     return(mux.poly)}
# 
# ##### If alpha does equal 2 #####
# mux.polyfnx2 = function(a.x, x_UL,x_LL){
#   mux.poly = (log(x_UL/x_LL))/(x_LL^(-1) - x_UL^-1)
#   return(mux.poly)}
# 
# ##### If alpha equals 1 #####
# mux.polyfnx1 = function(a.x, x_UL, x_LL){
#      mux.poly = (x_UL - x_LL)/(log(x_UL/x_LL)) #natural log
#     return(mux.poly)}

### Calculating max ingestible parameters ###
## function to calcualte min and max ingestible surface area ##
SAfnx = function(a, # a = 0.5 * length
                 b, # b = 0.5 * width
                 c # c = 0.5 * height (note that hieght is 0.67 * width)
){
  SA = 4*pi*(((a*b)^1.6 + (a*c)^1.6 + (b*c)^1.6) / 3)^(1/1.6)
  return(SA)}

## max ingestible volume ##

volumefnx = function(R, L){
  volume = 0.111667 * pi * R^2 * L^3 #assumes height = 0.67 * Width, and Width:Length ratio is 'R' (compartment-specific)
  return(volume)}

volumefnx_poly = function(width, length){
  height = width #0.67 * width
  volume = (4/3) * pi * (length/2) * (width/2) * (height/2) #assumes height = 0.67 * Width 
  return(volume)}

#max ingestible mass (only used for mu_mono calculations)
massfnx = function(R, L, p){
  mass = p * #density (g/cm^3)
    0.111667 * pi * R^2 * L^3 * # volume (um^3): assumes height = 0.67 * Width, and Width:Length ratio is 'R' (compartment-specific)
    1/1e12 * 1e6 #correction factor
  return(mass)}

massfnx_poly = function(width, length, p){
  height = width # 0.67 * width
  volume = (4/3) * pi * (length/2) * (width/2) * (height/2) #assumes height = 0.67 * Width 
  mass = p * #density (g/cm^3)
    volume * # volume (um^3): assumes height = 0.67 * Width, and Width:Length ratio is 'R' (compartment-specific)
    1/1e12 * 1e6 #correction factor
  return(mass)}

#max ingestible specific surface area
SSAfnx = function(sa, #surface area, calcaulted elsewhere
                  m){ #mass, calculated elsewhere
  SSA = sa/m
    return(SSA)}

#max ingestible specific surface area
SSA.inversefnx = function(sa, #surface area, calcaulted elsewhere
                  m){ #mass, calculated elsewhere
  SSA.inverse = m / sa
    return(SSA.inverse)}
```

#### Calculate

Here we will calculate two aligned exposure concentrations: surface area (1 - 83 um), and volume (1 - 5,000 um). For both, the upper aligned value is the smaller of either the nominal size listed or the mouth size of the species.

```{r}
###define sizes for alignment##
x1M_set <- 1 #um lower size for all alignments
x1D_set <- 1 #um lower size for all alignments
x2D_set <- 5000 #um
upper.tissue.trans.size.um <- 88 #10 #um #set size for x2M

# calculate ERM for each species
aoc_final <- aoc_intermediate_alphas  %>% 
  ungroup() %>% 
   #### TISSUE TRANSLOCATION ####
# define upper size length for Translocation 
#set to 83um for upper limit or max size ingest, whichever is smaller
mutate(x2M_trans = case_when(is.na(max.size.ingest.um) ~ upper.tissue.trans.size.um, 
                             max.size.ingest.um  < upper.tissue.trans.size.um ~  max.size.ingest.um,
                             max.size.ingest.um  > upper.tissue.trans.size.um ~ upper.tissue.trans.size.um)) %>% 
  
 # calculate effect threshold for particles
  mutate(EC_mono_p.particles.mL_trans = dose.particles.mL.master) %>% 
  mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
  mutate(mu.p.poly_trans = mux_polyfnx_generalizable(a.x = alpha, #alpha for particles
                                 x_UL= x2M_trans, #upper ingestible size limit (width of particle)
                                 x_LL = x1M_set)) %>% 
  # polydisperse effect threshold for particles
  mutate(EC_poly_p.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.p.mono)/mu.p.poly_trans) %>% 
   #calculate CF_bio for all conversions
  mutate(CF_bio_trans = CFfnx(x1M = x1M_set,#lower size bin
                        x2M = x2M_trans, #upper translocatable
                        x1D = x1D_set, #default
                        x2D = x2D_set,  #default
                        a = alpha)) %>%  
  ## Calculate environmentally relevant effect threshold for particles
  mutate(EC_env_p.particles.mL_trans = EC_poly_p.particles.mL_trans * CF_bio_trans) %>%  #aligned particle effect concentraiton (1-5000 um)
  
  #### Surface area ERM ####
##--- environmental calculations ---###
  #calculate lower translocatable surface area
  mutate(x_LL_sa_trans = SAfnx(a = 0.5 * x1D_set, #length
                               b = 0.5 * x1D_set, #0.5 * R.ave * x1D_set, #width
                               c = 0.5 * x1D_set  #0.5 * R.ave * 0.67 * x1D_set #height
                               )) %>%  
  #calculate upper translocatable surface area
  mutate(x_UL_sa_trans = SAfnx(a = 0.5 * x2M_trans, 
                               b = 0.5 * x2M_trans, #width #0.5 * R.ave * x2M, 
                               c = 0.5 * x2M_trans #heigth #0.5 * R.ave * 0.67 * x2M
                               )) %>%  
  #calculate mu_x_poly (env) for surface area
  mutate(mu.sa.poly_trans = mux_polyfnx_generalizable(a.sa, x_UL_sa_trans, x_LL_sa_trans)) %>% 
  
  ##--- laboratory calculations ---###
  ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
  #(note that if mixed particles were used, a different equation must be used)
  mutate(mu.sa.mono = case_when(
    polydispersity == "monodisperse" ~ particle.surface.area.um2, # use reported surface area in monodisperse
    polydispersity == "polydisperse" ~  mux_polyfnx_generalizable(a.x = a.sa, 
                                  x_LL = particle.surface.area.um2.min,
                                  x_UL = particle.surface.area.um2.max))) %>% 
  
   #calculate polydisperse effect concentration for surface area (particles/mL)
  mutate(EC_poly_sa.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.sa.mono)/mu.sa.poly_trans) %>%  
  #calculate environmentally realistic effect threshold
  mutate(EC_env_sa.particles.mL_trans = EC_poly_sa.particles.mL_trans * CF_bio_trans) %>% 
  
  ##### FOOD DILUTION ####
  # define upper size length for ingestion 
  mutate(x2M_ingest = case_when(is.na(max.size.ingest.um) ~ x2D_set, 
                         max.size.ingest.um < x2D_set ~ max.size.ingest.um,
                         max.size.ingest.um > x2D_set ~ x2D_set
                         )) %>%  #set to 5,000 as upper limit or max size ingest, whichever is smaller
 # calculate effect threshold for particles
  mutate(EC_mono_p.particles.mL_ingest = dose.particles.mL.master) %>% 
  mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
  mutate(mu.p.poly_ingest = mux_polyfnx_generalizable(a.x = alpha, #alpha for particles
                                 x_UL= x2M_ingest, #upper ingestible size limit
                                 x_LL = x1M_set)) %>% 
  # polydisperse effect threshold for particles
  mutate(EC_poly_p.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.p.mono)/mu.p.poly_ingest) %>% 
   #calculate CF_bio for all conversions
  mutate(CF_bio_ingest = CFfnx(x1M = x1M_set,#lower size bin
                        x2M = x2M_ingest, #upper ingestible length
                        x1D = x1D_set, #default
                        x2D = x2D_set,  #default upper size range
                        a = alpha)) %>%  
  ## Calculate environmentally relevant effect threshold for particles
  mutate(EC_env_p.particles.mL_ingest = EC_poly_p.particles.mL_ingest * CF_bio_ingest) %>%  #aligned particle effect concentraiton (1-5000 um)
  
  
  #### volume ERM ####
##--- environmental calculations ---###
  #calculate lower ingestible volume 
  mutate(x_LL_v_ingest = volumefnx_poly(length = x1D_set,
                                 width = x1D_set)) %>% 
  #calculate maximum ingestible volume 
  mutate(x_UL_v_ingest = volumefnx_poly(length = x2M_ingest, # length-limited
                                 #x2D_set, #upper definiton (accouunts for fibers) CONSERVATIVE
                                 width = x2M_ingest)) %>% #ingestion-limited
  # calculate mu.v.poly
  mutate(mu.v.poly_ingest = mux_polyfnx_generalizable(a.v, x_UL_v_ingest, x_LL_v_ingest)) %>% 
  ##--- laboratory calculations ---###
  ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
  #(note that if mixed particles were used, a different equation must be used)
  mutate(mu.v.mono = case_when(
    polydispersity == "monodisperse" ~ particle.volume.um3, # use reported volume in monodisperse
    polydispersity == "polydisperse" ~ mux_polyfnx_generalizable(a.x = a.v, 
                                                   x_LL = particle.volume.um3.min,
                                                   x_UL = particle.volume.um3.max))) %>% 
  
  #calculate polydisperse effect concentration for volume (particles/mL)
  mutate(EC_poly_v.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.v.mono)/mu.v.poly_ingest) %>%  
    #calculate environmentally realistic effect threshold
  mutate(EC_env_v.particles.mL_ingest = EC_poly_v.particles.mL_ingest * CF_bio_ingest) %>% 
  
   ###### CLEANUP #####
  mutate(particles.mL.ox.stress = EC_env_sa.particles.mL_trans,
         particles.mL.food.dilution = EC_env_v.particles.mL_ingest)
```

###### Save Aligned dataset
```{r}
#saveRDS(aoc_final,"G:/My Drive/MooreInstitute/Projects/ToMEx2.0_EcoToxRisk/data/output/aoc_final.RDS")

# save dataset for quality score hypothesis testing below
aoc_aligned_no_filters <- aoc_final

## dataset for thresholds
aoc_final <- aoc_final %>% 
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
         tier_zero_tech_f == "Red Criteria Passed",
         tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) 

saveRDS(aoc_final,
        "../data/output/aoc_final.RDS")
```


####Test to see if same thresholds attained in main risk calculation
##### SSD Functions
```{r}
#### define function for SSD generation for tier 1 ####
SSD_function_t1 <- function(filtered.data, hcxlcl){
  set.seed(99)
  #data collapse
collapsed <- filtered.data %>% 
  group_by(Species, Group) %>% 
  summarize(Conc = quantile(dose_new, 0.25))

 if(n_distinct(collapsed$Species) > 5){
#fit distributions
dists <- ssd_fit_dists(collapsed, left = "Conc", dists = c("weibull", "llogis", "lnorm", "gamma", "lgumbel"), computable = FALSE, silent = FALSE) 
#use average distribution with weighthing based on AICC
preds <- predict(dists, average = TRUE, 
                 #ic = "aicc",
                 nboot = nboot, ci= TRUE) 
#report HC metrics of interest
hc5lcl <- c(preds$lcl[hcxlcl]) #CI05
 } else {
hc5lcl <- NA   
 }

#values to extract
print(hc5lcl)
}

#### define function for SSD generation for tier 2 ####
SSD_function_t2 <- function(filtered.data, hcx){
  set.seed(99)
  #data collapse
collapsed <- filtered.data %>% 
  group_by(Species, Group) %>% 
  summarize(Conc = quantile(dose_new, 0.25))

 if(n_distinct(collapsed$Species) > 5){
#fit distributions
dists <- ssd_fit_dists(collapsed, left = "Conc", 
                       dists = c("weibull", "llogis", "lnorm", "gamma", "lgumbel"), computable = FALSE, silent = FALSE) 
#use average distribution with weighthing based on AICC
preds <- predict(dists, average = TRUE,# ic = "aicc",
                 nboot = nboot, ci= TRUE) 
#report HC metrics of interest
hcx_est <- c(preds$est[hcx]) #HC5
hcx05cl <- c(preds$lcl[hcx]) #CI05
hcx95cl <- c(preds$ucl[hcx]) #CI95
#values to extract
list(hcx_est = hcx_est,
     hcx05cl = hcx05cl,
     hcx95cl = hcx95cl)
 } else {
list(hcx_est = NA,
     hcx05cl = NA,
     hcx95cl = NA)
 }
}

#### define function for SSD generation for tiers 3 and 4 ####
SSD_function_t3_4 <- function(filtered.data, hcx){
  set.seed(99)
  #data collapse
collapsed <- filtered.data %>% 
  #filter specific things for tiers 3 and 4
   filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population")) %>% 
  group_by(Species, Group) %>% 
  summarize(Conc = quantile(dose_new, 0.50))
#fit distributions
 if(n_distinct(collapsed$Species) > 5){
dists <- ssd_fit_dists(collapsed, left = "Conc", dists = c("weibull", "llogis", "lnorm", "gamma", "lgumbel"), computable = FALSE, silent = FALSE) 
#use average distribution with weighthing based on AICC
preds <- predict(dists, average = TRUE, 
                 #ic = "aicc", 
                 nboot = nboot, ci= TRUE) 
#report HC metrics of interest
hcx_est <- c(preds$est[hcx]) #HC5
hcx05cl <- c(preds$lcl[hcx]) #CI05
hcx95cl <- c(preds$ucl[hcx]) #CI95
#values to extract
list(hcx_est = hcx_est,
     hcx05cl = hcx05cl,
     hcx95cl = hcx95cl)
 } else {
  list(hcx_est = NA,
     hcx05cl = NA,
     hcx95cl = NA)
}
}
```


##### Base Thresholds
```{r}
#filter out risk criteria (not done above)#
aoc_risk_paper <- aoc_final %>% 
  drop_na(effect.metric) %>% 
   filter(
     tier_zero_tech_f == ("Red Criteria Passed"))

####---- TISSUE TRANSLOCATION ------#####
filtered.data.small.default_t1.2 <- aoc_risk_paper %>% 
          mutate(dose_new = particles.mL.ox.stress / (af.time * af.noec)) %>%  
         drop_na(dose_new) %>% 
         mutate(dose_new = dose_new * 1000) %>% #convert particles/mL to particles/L
  filter(between(size.length.um.used.for.conversions, 1, upper.tissue.trans.size.um),
         shape_f != "Not Reported",
         poly_f != "Not Reported",
         !environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC")

filtered.data.small.default_t3.4 <- filtered.data.small.default_t1.2 %>% 
 filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"))

# get thresholds
small.default.t1 <- SSD_function_t1(filtered.data = filtered.data.small.default_t1.2, hcxlcl = 5)
small.default.t2 <- SSD_function_t2(filtered.data = filtered.data.small.default_t1.2, hcx = 5)
small.default.t3 <- SSD_function_t3_4(filtered.data = filtered.data.small.default_t3.4, hcx = 5)
small.default.t4 <- SSD_function_t3_4(filtered.data = filtered.data.small.default_t3.4, hcx = 10)

####---- Food Dilution ------#####
filtered.data.large.default_t1.2 <- aoc_risk_paper %>% 
   # remove algae, as food dilution MOE doesn't make sense for algae
  filter(Group != "Algae") %>% 
         mutate(dose_new = particles.mL.food.dilution / (af.time * af.noec)) %>%  
         drop_na(dose_new) %>% 
         mutate(dose_new = dose_new * 1000) %>% #convert particles/mL to particles/L
  filter(between(size.length.um.used.for.conversions, x1D_set, x2D_set),
         poly_f != "Not Reported",
         !environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC")

filtered.data.large.default_t3.4 <- filtered.data.large.default_t1.2 %>% 
 filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"))

# get thresholds
large.default.t1 <- SSD_function_t1(filtered.data = filtered.data.large.default_t1.2, hcxlcl = 5)
large.default.t2 <- SSD_function_t2(filtered.data = filtered.data.large.default_t1.2, hcx = 5)
large.default.t3 <- SSD_function_t3_4(filtered.data = filtered.data.large.default_t3.4, hcx = 5)
large.default.t4 <- SSD_function_t3_4(filtered.data = filtered.data.large.default_t3.4, hcx = 10)

base_thresholds <- tibble(
  "Tier" = c('Tier1', 'Tier2', 'Tier3', 'Tier4'),
  "Tissue Translocation (Default)" = c(small.default.t1, small.default.t2$hcx_est, small.default.t3$hcx_est, small.default.t4$hcx_est),
  "Food Dilution (Default)" = c(large.default.t1, large.default.t2$hcx_est, large.default.t3$hcx_est, large.default.t4$hcx_est),  "Tissue Translocation (5th %)" = c(NA, small.default.t2$hcx05cl, small.default.t3$hcx05cl, small.default.t4$hcx05cl),
  "Tissue Translocation (95th %)" = c(NA, small.default.t2$hcx95cl, small.default.t3$hcx95cl, small.default.t4$hcx95cl),
  "Food Dilution (5th %)" = c(NA, large.default.t2$hcx05cl, large.default.t3$hcx05cl, large.default.t4$hcx05cl),
  "Food Dilution (95th %)" = c(NA, large.default.t2$hcx95cl, large.default.t3$hcx95cl, large.default.t4$hcx95cl))



base_thresholds
```
```{r}
kable(base_thresholds)
```

```{r}
base_thresholds %>% 
  mutate_if(is.numeric, ~signif(., 2)) %>% 
  mutate(across(where(is.numeric), ~scales::comma(.))) %>% 
  mutate("Food (Marine/Fresh)" = paste0(`Food Dilution (Default)`, " (", `Food Dilution (5th %)`, " to ", `Food Dilution (95th %)`,")"),
         "Tissue (Marine/Fresh)" = paste0(`Tissue Translocation (Default)`, " (", `Tissue Translocation (5th %)`, " to ", `Tissue Translocation (95th %)`,")")) %>% 
  select(Tier, "Food (Marine/Fresh)", "Tissue (Marine/Fresh)")
```


![Agreed-upon framework](assets/treshold_framework.png)

**Threshold 1:**
*HC*: HC5
*Data collapsing*: 1st quartile
*Point estimate*: lower 95% (of distribution)
*Biological scale of endpoints*: molecular to population

**Threshold 2:**
*HC*: HC5
*Data collapsing*: 1st quartile
*Point estimate*: median (of distribution)
*Biological scale of endpoints*: molecular to population

**Threshold 3:**
*HC*: HC5
*Data collapsing*: median
*Point estimate*: median
*Biological scale of endpoints*: organismal and population

**Threshold 4:**
*HC*: HC10
*Data collapsing*: median
*Point estimate*: median
*Biological scale of endpoints*: organismal and population

The figure above displays the working threshold framework for the ambient threshold group for the Microplastics Health Effects Workshop. 

The current framework for generating SSDs includes the following parameters:



Data pertaining to only aquatic organisms are included (marine and freshwater).  

All taxa are included with the exception of bacterium and plants.  

HONEC (Highest Observed No Effect Concentration) are excluded.  

Assessment factors are applied to convert all other effect metrics into NOECs:

![](../assets/AF_EM.png)

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)  

Assessment factors are applied to convert acute data into chronic:  

![](../assets/AF_chronic.png)

Green rows are from Wigger et al. 2020. Grey rows were agreed upon by the ambient threshold working group.

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)

Note: Values may be slightly different than those presented in the shiny app as concentrations are converted from particles/mL to particles/L ahead of calculations.

## Quality score testing
Do thresholds differ significantly when only studies passing red criteria (technical, risk applicability) are used/not? 

### Functionalize threshold derivation
```{r}
nboot = 10 #ssd bootstraps
n_sim <- 1 #deterministic analysis
R.ave.water.marine <- 0.77 # average length to width ratio of microplastics in marine environment (Kooi et al. 2021)
R.ave.water.freshwater <- 0.67 # average length to width ratio of microplastics in freshwater environment (Kooi et al. 2021)
R.ave.sediment.marine <- 0.75 # average length to width ratio of microplastics in marine environment (Kooi et al. 2021)
R.ave.sediment.freshwater <- 0.70 # average length to width ratio of microplastics in freshwater environment (Kooi et al. 2021)
p.ave.marine = 1.10 #average density in marine surface water
alpha.marine = 2.07 #table s4 for marine surface water. length
a.sa.marine = 1.50 #marine surface area power law
a.v.marine = 1.48 #a_V for marine surface water volume
a.m.marine = 1.32 # upper limit fora_m for mass for marine surface water in table S4 
a.ssa.marine = 1.98 # A_SSA for marine surface water
p.ave.freshwater = 1.04 #average density in freshwater surface water
alpha.freshwater = 2.64 #table s4 for freshwater surface water. length
a.sa.freshwater = 2.00 #freshwater surface area power law
a.v.freshwater = 1.68 #a_V for freshwater surface water volume
a.m.freshwater = 1.65 # upper limit fora_m for mass for freshwater surface water in table S4 
a.ssa.freshwater = 2.71 # A_SSA for freshwater surface water
upper.tissue.trans.size.um <- 88 #um #set size for filtering data and x2M
beta_log10_body_length <- 0.9341
body_length_intercept <- 1.1200
```

RUN THESE IN CONSOLE
```{r}
getwd()
##### STEP 1: DERIVE VALUES TO RUN PROBABILISTICALLY #####
source("monte carlo/ssd_functions.R")
## these locations are correct, but for some reason R won't locate them. Run in console
#source("scripts/monte carlo/RDAmaker_functions.R") #get ToMEx1.0 fxn
#source("scripts/monte carlo/ToMEx2.0_Data_Tidying_functions.R")
library(here)
here()
source(here("scripts/monte carlo/RDAmaker_functions.R")) #get ToMEx1.0 fxn
source("monte carlo/ToMEx2.0_Data_Tidying_functions.R") 
```
RUN THESE IN CONSOLE
```{r}

## Some alignments are done in these data processing scripts
## generate ToMEx 1.0 dataset ###
  aoc_setup <- ToMEx1.0fxn(R.ave.water.marine = R.ave.water.marine,
                           R.ave.water.freshwater = R.ave.water.freshwater,
                           R.ave.sediment.marine = R.ave.sediment.marine,
                           R.ave.sediment.freshwater = R.ave.sediment.freshwater,
                           beta_log10_body_length = beta_log10_body_length,
                           body_length_intercept = body_length_intercept) 
  
## generate ToMEx 2.0 dataset ###
  tomex2.0_aoc_z_final <- ToMEx2.0fxn(aoc_setup = aoc_setup,
                                      R.ave.water.marine = R.ave.water.marine,
                                      R.ave.water.freshwater = R.ave.water.freshwater,
                                      R.ave.sediment.marine = R.ave.sediment.marine,
                                      R.ave.sediment.freshwater = R.ave.sediment.freshwater,
                                      beta_log10_body_length = beta_log10_body_length,
                                      body_length_intercept = body_length_intercept) %>% 
    mutate(environment = env_f)

```

```{r}  
# define function for deriving thresholds with different quality filtered datasets   
calculate_thresholds <- function(data, label) {
  
   aoc_iter <- data  %>% 
    #drop_na(effect.metric) %>% 
    ungroup() %>% 
    ### First filter the data ####
  ## First filter data with global filters
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
  ) %>% 
    #Remove 26C temperature treatment data from Jaimukar et al. 2018
    filter(!(article == 42 & media.temp == 26)) %>% 
    mutate(max.size.ingest.um = 1000 * max.size.ingest.mm) %>%  #makes it less confusing below
    # calculate ERM for each species
    #### TISSUE TRANSLOCATION ####
  # define upper size length for Translocation 
  #set to 83um for upper limit or max size ingest, whichever is smaller
  mutate(x2M_trans = case_when(
    is.na(max.size.ingest.um) ~ upper.tissue.trans.size.um,
    TRUE ~ pmin(max.size.ingest.um, upper.tissue.trans.size.um)
  )) %>% 
    # define environment-specific alpha parameters #
    mutate(alpha = case_when(environment == "Marine" ~ alpha.marine,
                             environment == "Freshwater" ~ alpha.freshwater),
           a.sa = case_when(environment == "Marine" ~ a.sa.marine,
                            environment == "Freshwater" ~ a.sa.freshwater),
           a.v = case_when(environment == "Marine" ~ a.v.marine,
                            environment == "Freshwater" ~ a.v.freshwater),
           a.m = case_when(environment == "Marine" ~ a.m.marine,
                           environment == "Freshwater" ~ a.m.freshwater),
           a.ssa = case_when(environment == "Marine" ~ a.ssa.marine,
                           environment == "Freshwater" ~ a.ssa.freshwater),
           ) %>% 
    # calculate effect threshold for particles
    mutate(EC_mono_p.particles.mL_trans = dose.particles.mL.master) %>% 
    mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
    mutate(mu.p.poly_trans = mux_polyfnx_generalizable(a.x = alpha, #alpha for particles
                                         x_UL= x2M_trans, #upper ingestible size limit (width of particle)
                                         x_LL = x1M_set)) %>% 
    # polydisperse effect threshold for particles
    mutate(EC_poly_p.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.p.mono)/mu.p.poly_trans) %>% 
    #calculate CF_bio for all conversions
    mutate(CF_bio_trans = CFfnx(x1M = x1M_set,#lower size bin
                                x2M = x2M_trans, #upper translocatable
                                x1D = x1D_set, #default
                                x2D = x2D_set,  #default
                                a = alpha)) %>%  
    ## Calculate environmentally relevant effect threshold for particles
    mutate(EC_env_p.particles.mL_trans = EC_poly_p.particles.mL_trans * CF_bio_trans) %>%  #aligned particle effect concentraiton (1-5000 um)
    
    #### Surface area ERM ####
  ##--- environmental calculations ---###
  #calculate lower translocatable surface area
  mutate(x_LL_sa_trans = SAfnx(a = 0.5 * x1D_set, #length
                               b = 0.5 * x1D_set, #0.5 * R.ave * x1D_set, #width
                               c = 0.5 * x1D_set  #0.5 * R.ave * 0.67 * x1D_set #height
  )) %>%  
    #calculate upper translocatable surface area
    mutate(x_UL_sa_trans = SAfnx(a = 0.5 * x2M_trans, 
                                 b = 0.5 * x2M_trans, #width #0.5 * R.ave * x2M, 
                                 c = 0.5 * x2M_trans #heigth #0.5 * R.ave * 0.67 * x2M
    )) %>%  
    #calculate mu_x_poly (env) for surface area
    mutate(mu.sa.poly_trans = mux_polyfnx_generalizable(a.sa, x_UL_sa_trans, x_LL_sa_trans)) %>% 
    
    ##--- laboratory calculations ---###
    ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
    #(note that if mixed particles were used, a different equation must be used)
    mutate(mu.sa.mono = case_when(
      polydispersity == "monodisperse" ~ particle.surface.area.um2, # use reported surface area in monodisperse
      polydispersity == "polydisperse" ~  mux_polyfnx_generalizable(a.x = a.sa, 
                                                      x_LL = particle.surface.area.um2.min,
                                                      x_UL = particle.surface.area.um2.max))) %>% 
    
    #calculate polydisperse effect concentration for surface area (particles/mL)
    mutate(EC_poly_sa.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.sa.mono)/mu.sa.poly_trans) %>%  
    #calculate environmentally realistic effect threshold
    mutate(EC_env_sa.particles.mL_trans = EC_poly_sa.particles.mL_trans * CF_bio_trans) %>% 
    
    ##### FOOD DILUTION ####
  # define upper size length for ingestion 
  mutate(x2M_ingest = case_when(is.na(max.size.ingest.um) ~ x2D_set, 
                                max.size.ingest.um < x2D_set ~ max.size.ingest.um,
                                max.size.ingest.um > x2D_set ~ x2D_set
  )) %>%  #set to 5,000 as upper limit or max size ingest, whichever is smaller
    # calculate effect threshold for particles
    mutate(EC_mono_p.particles.mL_ingest = dose.particles.mL.master) %>% 
    mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
    mutate(mu.p.poly_ingest = mux_polyfnx_generalizable(a.x = alpha, #alpha for particles
                                          x_UL= x2M_ingest, #upper ingestible size limit
                                          x_LL = x1M_set)) %>% 
    # polydisperse effect threshold for particles
    mutate(EC_poly_p.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.p.mono)/mu.p.poly_ingest) %>% 
    #calculate CF_bio for all conversions
    mutate(CF_bio_ingest = CFfnx(x1M = x1M_set,#lower size bin
                                 x2M = x2M_ingest, #upper ingestible length
                                 x1D = x1D_set, #default
                                 x2D = x2D_set,  #default upper size range
                                 a = alpha)) %>%  
    ## Calculate environmentally relevant effect threshold for particles
    mutate(EC_env_p.particles.mL_ingest = EC_poly_p.particles.mL_ingest * CF_bio_ingest) %>%  #aligned particle effect concentraiton (1-5000 um)
    
    
    #### volume ERM ####
  ##--- environmental calculations ---###
  #calculate lower ingestible volume 
  mutate(x_LL_v_ingest = volumefnx_poly(length = x1D_set,
                                        width = x1D_set)) %>% 
    #calculate maximum ingestible volume 
    mutate(x_UL_v_ingest = volumefnx_poly(length = x2M_ingest, # length-limited
                                          #x2D_set, #upper definiton (accouunts for fibers) CONSERVATIVE
                                          width = x2M_ingest)) %>% #ingestion-limited
    # calculate mu.v.poly
    mutate(mu.v.poly_ingest = mux_polyfnx_generalizable(a.v, x_UL_v_ingest, x_LL_v_ingest)) %>% 
    ##--- laboratory calculations ---###
    ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
    #(note that if mixed particles were used, a different equation must be used)
    mutate(mu.v.mono = case_when(
      polydispersity == "monodisperse" ~ particle.volume.um3, # use reported volume in monodisperse
      polydispersity == "polydisperse" ~ mux_polyfnx_generalizable(a.x = a.v, 
                                                     x_LL = particle.volume.um3.min,
                                                     x_UL = particle.volume.um3.max))) %>% 
    
    #calculate polydisperse effect concentration for volume (particles/mL)
    mutate(EC_poly_v.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.v.mono)/mu.v.poly_ingest) %>%  
    #calculate environmentally realistic effect threshold
    mutate(EC_env_v.particles.mL_ingest = EC_poly_v.particles.mL_ingest * CF_bio_ingest) %>% 
    
    ###### CLEANUP #####
  mutate(particles.mL.ox.stress = EC_env_sa.particles.mL_trans,
         particles.mL.food.dilution = EC_env_v.particles.mL_ingest) %>% 
    #### annotate studies in which particles are too big to be ingested or translocated for those ERMs (to be filtered in ssd functions)
    mutate(translocatable = as.factor(ifelse(size.length.um.used.for.conversions > x2M_trans, 
                                   "not translocatable", 
                                   "translocatable"))) %>% 
    mutate(ingestible = as.factor(ifelse(size.length.um.used.for.conversions > x2M_ingest, 
                               "not ingestible", 
                               "ingestible"))) %>% 
    
    #rowwise() %>%
    mutate(unique_id = row_number()) %>% 
    # mutate(unique_id = digest::digest(paste(across(everything()), collapse = "-"), algo = "md5")) %>%
    ungroup()
  

  # calculate thresholds for different environments
  marine_thresholds <- process_environment_data(aoc_iter,
                                                "Marine", 
                                                upper.tissue.trans.size.um = upper.tissue.trans.size.um,
                                                x1D_set = x1D_set, 
                                                x2D_set = x2D_set) %>% 
    mutate("label" = as.character(label))
  
  freshwater_thresholds <- process_environment_data(aoc_iter, 
                                                    "Freshwater",
                                                    upper.tissue.trans.size.um = upper.tissue.trans.size.um,
                                                    x1D_set = x1D_set, 
                                                    x2D_set = x2D_set)  %>% 
    mutate("label" = as.character(label))
  
  
  freshwater_marine_thresholds <- process_environment_data(aoc_iter, 
                                                           c("Freshwater", "Marine"),
                                                           upper.tissue.trans.size.um = upper.tissue.trans.size.um,
                                                           x1D_set = x1D_set, 
                                                           x2D_set = x2D_set) %>% 
    mutate("label" = as.character(label))
  
  
  ##### SAVE OUTPUT OF MONTE CARLO ######
  
  thresholds_results <- list("label" = as.character(label), 
                                  particles_mL_ox_stress = aoc_iter$particles.mL.ox.stress,
                                  particles_mL_food_dilution = aoc_iter$particles.mL.food.dilution,
                                  unique_id = aoc_iter$unique_id,
                                  base_thresholds = list(
                                    "label" = as.character(label), 
                                    marine = marine_thresholds,
                                    freshwater = freshwater_thresholds,
                                    freshwater_marine = freshwater_marine_thresholds
                                    ))
  
  return(thresholds_results)
  } #close model_wrapper function
```

```{r eval=FALSE, include=FALSE}
# calculate_thresholds <- function(data, label) {
#   
#  #filter out risk criteria (not done above)#
# aoc_risk_paper <- data %>% 
#   drop_na(effect.metric)
# 
# ####---- TISSUE TRANSLOCATION ------#####
# filtered.data.small.default_t1.2 <- aoc_risk_paper %>% 
#           mutate(dose_new = particles.mL.ox.stress / (af.time * af.noec)) %>%  
#          drop_na(dose_new) %>% 
#           filter(dose_new > 0) %>% 
#          mutate(dose_new = dose_new * 1000) %>% #convert particles/mL to particles/L
#   filter(between(size.length.um.used.for.conversions, 1, upper.tissue.trans.size.um),
#          shape_f != "Not Reported",
#          poly_f != "Not Reported",
#          !environment %in% c("Terrestrial", "Not Reported"),
#          Group != "Bacterium",
#          Group != "Plant",
#          effect.metric != "HONEC")
# 
# filtered.data.small.default_t3.4 <- filtered.data.small.default_t1.2 %>% 
#  filter(risk.13 != 1,
#          bio_f %in% c("Organism", "Population"))
# 
# # get thresholds
# small.default.t1 <- SSD_function_t1(filtered.data = filtered.data.small.default_t1.2, hcxlcl = 5)
# small.default.t2 <- SSD_function_t2(filtered.data = filtered.data.small.default_t1.2, hcx = 5)
# small.default.t3 <- SSD_function_t3_4(filtered.data = filtered.data.small.default_t3.4, hcx = 5)
# small.default.t4 <- SSD_function_t3_4(filtered.data = filtered.data.small.default_t3.4, hcx = 10)
# 
# ####---- Food Dilution ------#####
# filtered.data.large.default_t1.2 <- aoc_risk_paper %>% 
#    # remove algae, as food dilution MOE doesn't make sense for algae
#   filter(Group != "Algae") %>% 
#          mutate(dose_new = particles.mL.food.dilution / (af.time * af.noec)) %>%  
#          drop_na(dose_new) %>% 
#          mutate(dose_new = dose_new * 1000) %>% #convert particles/mL to particles/L
#   filter(dose_new > 0) %>% 
#   filter(between(size.length.um.used.for.conversions, x1D_set, x2D_set),
#          poly_f != "Not Reported",
#          !environment %in% c("Terrestrial", "Not Reported"),
#          Group != "Bacterium",
#          Group != "Plant",
#          effect.metric != "HONEC")
# 
# filtered.data.large.default_t3.4 <- filtered.data.large.default_t1.2 %>% 
#  filter(risk.13 != 1,
#          bio_f %in% c("Organism", "Population"))
# 
# # get thresholds
# large.default.t1 <- SSD_function_t1(filtered.data = filtered.data.large.default_t1.2, hcxlcl = 5)
# large.default.t2 <- SSD_function_t2(filtered.data = filtered.data.large.default_t1.2, hcx = 5)
# large.default.t3 <- SSD_function_t3_4(filtered.data = filtered.data.large.default_t3.4, hcx = 5)
# large.default.t4 <- SSD_function_t3_4(filtered.data = filtered.data.large.default_t3.4, hcx = 10)
# 
# base_thresholds <- tibble(
#   "label" = as.character(label), 
#   "Tier" = c('Tier1', 'Tier2', 'Tier3', 'Tier4'),
#   "Tissue Translocation (Default)" = c(small.default.t1, small.default.t2$hcx_est, small.default.t3$hcx_est, small.default.t4$hcx_est),
#   "Food Dilution (Default)" = c(large.default.t1, large.default.t2$hcx_est, large.default.t3$hcx_est, large.default.t4$hcx_est),  "Tissue Translocation (5th %)" = c(NA, small.default.t2$hcx05cl, small.default.t3$hcx05cl, small.default.t4$hcx05cl),
#   "Tissue Translocation (95th %)" = c(NA, small.default.t2$hcx95cl, small.default.t3$hcx95cl, small.default.t4$hcx95cl),
#   "Food Dilution (5th %)" = c(NA, large.default.t2$hcx05cl, large.default.t3$hcx05cl, large.default.t4$hcx05cl),
#   "Food Dilution (95th %)" = c(NA, large.default.t2$hcx95cl, large.default.t3$hcx95cl, large.default.t4$hcx95cl))
# 
# return(base_thresholds)
# }
# 
# ## example usage
# #base_thresholds <- calculate_thresholds(aoc_final, label = "no quality filters")


```

### Data filtering and run threshold derivation
```{r}
#filter out risk and tech criteria
aoc_risk_paper <- tomex2.0_aoc_z_final %>% 
  drop_na(effect.metric) %>% 
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
         tier_zero_tech_f == "Red Criteria Passed",
         tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) 

#filter out tech criteria
aoc_tech_only <- tomex2.0_aoc_z_final %>% 
  drop_na(effect.metric) %>% 
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
         tier_zero_tech_f == "Red Criteria Passed",
       #  tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) 

#filter out risk criteria
aoc_risk_only <- tomex2.0_aoc_z_final %>% 
  drop_na(effect.metric) %>% 
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
       #  tier_zero_tech_f == "Red Criteria Passed",
         tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) 

#no filters
aoc_aligned_no_filters %>% 
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC") 
```

```{r}
# run
risk_tech <- calculate_thresholds(aoc_risk_paper, label = "risk and tech")
tech <- calculate_thresholds(aoc_tech_only, label = "tech only")
risk <- calculate_thresholds(aoc_risk_only, label = "risk only")
no_quality <- calculate_thresholds(aoc_aligned_no_filters, label = "no quality filters")

#unified_thresholds <- bind_rows(risk_tech, tech, risk, no_quality)

#print(unified_thresholds)
```

```{r}
# Extract and combine base_thresholds for each environment
all_thresholds_marine <- bind_rows(risk_tech$base_thresholds$marine,
                                   tech$base_thresholds$marine,
                                   risk$base_thresholds$marine,
                                   no_quality$base_thresholds$marine)

all_thresholds_freshwater <- bind_rows(risk_tech$base_thresholds$freshwater,
                                       tech$base_thresholds$freshwater,
                                       risk$base_thresholds$freshwater,
                                       no_quality$base_thresholds$freshwater)

all_thresholds_freshwater_marine <- bind_rows(risk_tech$base_thresholds$freshwater_marine,
                                                     tech$base_thresholds$freshwater_marine,
                                                     risk$base_thresholds$freshwater_marine,
                                                     no_quality$base_thresholds$freshwater_marine)


# Combine marine and freshwater data into one data frame with an additional "Environment" column
all_thresholds_combined <- bind_rows(
  mutate(all_thresholds_marine, Environment = "Marine"),
  mutate(all_thresholds_freshwater, Environment = "Freshwater"),
  mutate(all_thresholds_freshwater_marine, Environment = "Freshwater & Marine")) %>% 
  mutate(Environment = as.factor(Environment),
         label = factor(label, levels = c(
           "no quality filters",
           "tech only",
           "risk only",
           "risk and tech"
         )))

# pivot_longer
all_thresholds_long <- all_thresholds_combined %>%
  pivot_longer(
    cols = -c(Tier, label, Environment),
    names_to = "Metric",
    values_to = "Value"
  )
all_thresholds_long
```
#### Visualize quality score thresholds
```{r}
library(ggtext)

quality_colors <- c("risk and tech" = "#006f3c", "risk only" = "#264b96",
                    "tech only" = "#f9a73e", "no quality filters" = "#bf212f")

food_quality <- all_thresholds_combined %>% 
  mutate(y_label = paste0("<span style='color:", quality_colors[label], "'>", label, "</span>")) %>% 
  filter(Tier == "Tier2",
         Environment != "Freshwater & Marine") %>% 
  ggplot(aes(x = `Food Dilution (Default)`, y = label, color = label)) +
  geom_point(size = 4) +
  geom_errorbarh(aes(xmin = `Food Dilution (5th %)`,
                     xmax = `Food Dilution (95th %)`),
                  height = 0.2,
                  alpha = 0.75#,
                 # linehe = 1.2
                 ) +
  scale_color_manual(values = quality_colors) +
  geom_text(aes(label = signif(`Food Dilution (Default)`, 3)), vjust = -0.5) +
  xlab("Particles/L (Food Dilution)") +
  ylab("Quality Filters") +
  scale_x_log10(labels = scales::comma) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none") +
       # axis.text.y = element_markdown()) + # Use element_markdown for y-axis labels
 #scale_y_discrete(labels = setNames(y_label, label)) +
  facet_wrap(~Environment)

tissue_quality <- all_thresholds_combined %>% 
  filter(Tier == "Tier2",
         Environment != "Freshwater & Marine") %>% 
  ggplot(aes(x = `Tissue Translocation (Default)`, y = label, color = label)) +
  geom_point(size = 4) +
  geom_errorbarh(aes(xmin = `Tissue Translocation (5th %)`,
                     xmax = `Tissue Translocation (95th %)`),
                  height = 0.2,
                  alpha = 0.75#,
                 # linehe = 1.2
                 ) +
  scale_color_manual(values = quality_colors) +
  geom_text(aes(label = signif(`Tissue Translocation (Default)`,3)), vjust = -0.5) +
  scale_x_log10(labels = scales::comma) +
  xlab("Particles/L (Tissue Translocation)") +
  ylab("Quality Filters") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none") +
  facet_wrap(~Environment)

quality_tier2 <-  ggarrange(food_quality, tissue_quality,
                            labels = c("A", "B"),
                            nrow = 2)

ggsave(plot = quality_tier2,
       filename = "../output/Manuscript_Figs/quality_tier2.jpg",
      dpi = 300,
      width = 7, height = 5, units = "in")

quality_tier2
```

### Export quality threshold data to excel
```{r}
getwd()
write.csv(all_thresholds_combined, "../output/data/all_thresholds_combined_quality.csv")
```

#### Maximize quality filters
We need to perform an iterative approach to filter the dataset based on quality criteria and ensure that the filtered dataset contains at least 6 unique species. We will maximize the quality of studies used to derive thresholds by trying different combinations of quality criteria.

Here's how you can do it:

Create a function to filter the dataset based on a given set of quality criteria.
Create a function to check if a dataset has at least 6 unique species.
Iterate over all possible combinations of quality criteria to find the best quality dataset that meets the minimum species requirement.
Run the SSD functions on the best quality dataset.

##### Exhaustive Approach

Number of Combinations: 
2 ^ 27  1  134,217,727 combinations. Could take ~37 hrs to run.
```{r}
# Define quality criteria
quality_criteria <- c("tech.a1", "tech.a2", "tech.a3", "tech.a4", "tech.a5", "tech.a6", "tech.1",
                      "tech.2", "tech.3", "tech.4", "tech.5", "tech.6", "tech.7", "tech.8", "tech.9",
                      "tech.10", "tech.11", "tech.12", "risk.b1", "risk.13", "risk.14",
                      "risk.15", "risk.16", "risk.17", "risk.18", "risk.19", "risk.20")

red_criteria <- c("tech.a1", "tech.a2", "tech.a3", "tech.a4", "tech.a5", "tech.a6", 
                  "tech.1", "tech.2", "tech.3", "tech.4", "tech.5", "risk.13", "risk.b1")

#only use the criteria with variabilty (i.e., minus the red)
variable_criteria <- setdiff(quality_criteria, red_criteria)
variable_criteria_doi <- c(variable_criteria, "doi")

#calculate number of combinations
estimated_time_seconds =  2 ^ n_distinct(variable_criteria) * 0.001 #seconds per iteration
estimated_time_hours = (estimated_time_seconds / 60)/60
estimated_time_hours
```

```{r}
aoc_risk_paper_filtered <- aoc_risk_paper %>% 
  drop_na(effect.metric) %>% 
  filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"),
          Group != "Algae")

### collapse dataset to unique combo of DOI and variable quality criteria to speed up combination testing below
# Step 1. just get at experiment-level data and annotate with unique ID
aoc_risk_collapsed <- aoc_risk_paper %>%
 distinct(across(all_of(variable_criteria_doi)), .keep_all = TRUE)
```

```{r eval=FALSE, include=FALSE}
# Function to filter dataset based on quality criteria
filter_quality <- function(data, criteria) {
  for (criterion in criteria) {
    data <- data %>% filter(!!sym(criterion) > 0)
  }
  return(data)
}

# Function to check if the dataset has at least 6 unique species
has_minimum_species <- function(data) {
  return(length(unique(data$Species)) >= 6)
}

# Function to find the best quality dataset that meets the minimum species requirement
find_best_quality_dataset <- function(data, quality_criteria) {
  best_data <- data
  best_quality <- 0
  all_combinations <- unlist(lapply(1:length(quality_criteria), function(x) combn(quality_criteria, x, simplify = FALSE)), recursive = FALSE)
  
  for (combination in all_combinations) {
    filtered_data <- filter_quality(data, combination)
    if (has_minimum_species(filtered_data)) {
      current_quality <- sum(sapply(combination, function(x) mean(filtered_data[[x]], na.rm = TRUE)))
      if (current_quality > best_quality) {
        best_quality <- current_quality
        best_data <- filtered_data
      }
    }
  }
  
  return(best_data)
}

#find best possible dataset
#beta_test <- find_best_quality_dataset(aoc_risk_collapsed, c("tech.8", "tech.9", "tech.10", "risk.15"))
best_data <- find_best_quality_dataset(aoc_risk_paper_filtered, variable_criteria)
##examine dataset
best_data %>% select(c(Species, total.quality, contains("tech"), contains("risk"))) %>% 
  distinct()
```


```{r}
#derive best possible thresholds
best_data_thresholds <- calculate_thresholds(best_data, label = "best data")
```
##### Heuristic/GREEDY Method
We can employ a heuristic approach to prioritize checking the combinations that are more likely to yield high-quality datasets early, such as starting with the criteria that have the highest average scores or using a greedy algorithm.



```{r}
# Function to filter dataset based on quality criteria
filter_quality <- function(data, criteria) {
  for (criterion in criteria) {
    data <- data %>% filter(!!sym(criterion) > 0)
  }
  return(data)
}

# Function to check if the dataset has at least 6 unique species
has_minimum_species <- function(data) {
  return(length(unique(data$species)) >= 6)
}

# Heuristic function to find a good quality dataset
find_best_quality_dataset <- function(data, quality_criteria) {
  best_data <- data
  best_quality <- 0
  
  for (criterion in quality_criteria) {
    filtered_data <- filter_quality(data, criterion)
    if (has_minimum_species(filtered_data)) {
      current_quality <- mean(filtered_data[[criterion]], na.rm = TRUE)
      if (current_quality > best_quality) {
        best_quality <- current_quality
        best_data <- filtered_data
      }
    }
  }
  
  return(best_data)
}

# Find the best quality dataset for each case
best_data <- find_best_quality_dataset(aoc_risk_paper, quality_criteria)

best_data %>% select(c(Species, total.quality, contains("tech"), contains("risk"))) %>% 
  distinct() %>% 
  arrange(desc(Species))
```

```{r}
# Example usage with best quality datasets
best_data_thresholds <- calculate_thresholds(best_data, label = "best data")

# Combine all thresholds into a single table

unified_thresholds <- bind_rows(risk_tech, tech, risk, no_quality, best_data_thresholds)

# Print the unified thresholds table
print(unified_thresholds)

```
# Sensitivity Analysis
## Leave-one-out method
These techniques are based on the Leave-One-Out-method, in which we recalculate the results of our meta-analysis K  1  times, each times leaving out one study. This way, we can more easily detect studies which influence the overall estimate of our meta-analysis the most, and this lets us better assess if this influence may distort our pooled effect (Viechtbauer and Cheung 2010).
### Functions
```{r}
create_leave_one_out_function_t1 <- function(filtered_data) {
  # Vectorized leave-one-out function
  sensitivity_t1 <- Vectorize(function(x, y) {
    # Exclude the current study (doi) from the training set
    train <- filtered_data[!filtered_data$doi %in% x,]
    # Apply the SSD function
    SSD_function_t1(train, hcxlcl = y)  
  })
  
  # Return the vectorized function
  sensitivity_t1
}

create_leave_one_out_function_t2 <- function(filtered_data) {
  # Vectorized leave-one-out function
  sensitivity_t2 <- Vectorize(function(x, y) {
    # Exclude the current study (doi) from the training set
    train <- filtered_data[!filtered_data$doi %in% x,]
    # Apply the SSD function
    hc <- SSD_function_t2(train, hcx = y)
    hc <- hc$hcx_est[1]
    hc
  })
  
  # Return the vectorized function
  sensitivity_t2
}

create_leave_one_out_function_t3_4 <- function(filtered_data) {
  # Vectorized leave-one-out function
  sensitivity_t3_4 <- Vectorize(function(x, y) {
    # Exclude the current study (doi) from the training set
    train <- filtered_data[!filtered_data$doi %in% x,]
    # Apply the SSD function
    hc <- SSD_function_t3_4(train, hcx = y)
    hc <- hc$hcx_est[1]
    hc
  })
  
  # Return the vectorized function
  sensitivity_t3_4
}

#tier 1 function
leave_one_out_tier_1 <- function(filtered_data, 
                                 hcx, ERM_input, tier_input, environment_input) {
  hcxlcl_list <- list(hcxlcl = hcx)
  #base HCx
  filtered_data_hcxlcl <- SSD_function_t1(filtered.data = filtered_data, hcx)
  unique.dois <- unique(filtered_data$doi)
  # Create the leave-one-out function with your filtered data
  leave_one_out <- create_leave_one_out_function_t1(filtered_data)
  # Apply the leave-one-out function
  sensitivity_vector <- leave_one_out(unique.dois, hcxlcl_list)
  sensitivity_matrix <- matrix(sensitivity_vector, nrow = length(unique.dois), byrow = TRUE)
  rownames(sensitivity_matrix) <- unique.dois
  #bind DOI's to other parameters of interest for analysis
  sensitivity_tbl <- rownames_to_column(as.data.frame(sensitivity_matrix), var = c("doi")) %>%
    rename(hcxlcl = V1)
  # join to other parameters of interest
   sensitivity_df <- left_join(sensitivity_tbl, filtered_data, by = "doi") %>% 
    dplyr::select(authors, year, Species, dose_new, 
                  hcxlcl, acute.chronic_f, bio_f, lvl2_f,
                  size.length.um.used.for.conversions, doi) %>% 
    distinct(doi, authors, year, hcxlcl, Species, acute.chronic_f,
             size.length.um.used.for.conversions) %>% 
    mutate(authoryear = paste(authors, "et. al ", year)) %>% 
    mutate(hcxlcl = replace_na(hcxlcl, 0)) %>% #studies with n_species < 5 will get a 0
    mutate(authoryear = fct_reorder(authoryear, hcxlcl, na.rm = FALSE)) %>% 
    mutate(diff = (hcxlcl - filtered_data_hcxlcl)/filtered_data_hcxlcl,
           tier = as.character(tier_input),
           ERM = as.character(ERM_input),
           environment = as.character(environment_input))
  
  sensitivity_summary <- sensitivity_df %>% 
    rename(hcx = hcxlcl) %>% 
    group_by(doi, authoryear, diff, hcx) %>% 
    summarise(species_multiple = paste(unique(Species), collapse = ", "),
              .groups = "keep") %>% 
    ungroup() %>% 
    arrange(desc(hcx)) %>% 
    mutate(hcx = case_when(hcx == 0 ~ NA,
                           TRUE ~ hcx),
           diff = case_when(diff == -1 ~ NA,
                            TRUE ~ diff)) %>% 
    mutate(sufficient_species = case_when(!is.na(hcx) ~ "sufficient",
                                          is.na(hcx) ~ "insufficient"),
           ERM = as.character(ERM_input),
           environment = as.character(environment_input),
           tier = as.character(tier_input)) #annotate for full dataset))
 
   return(list(sensitivity_df = sensitivity_df, 
               sensitivity_summary = sensitivity_summary))
}

# Tier 2 function
leave_one_out_tier2 <- function(filtered_data, hcx_num, ERM_input, tier_input, environment_input) {
  hcx_list <- list(hcx = hcx_num)
  #base HCx
  filtered_data_hcx <- SSD_function_t2(filtered.data = filtered_data, hcx_num)
  filtered_data_hcx <- filtered_data_hcx$hcx_est[1]
  unique.dois <- unique(filtered_data$doi)
  # Create the leave-one-out function with your filtered data
  leave_one_out <- create_leave_one_out_function_t2(filtered_data)
  # Apply the leave-one-out function
  sensitivity_vector <- leave_one_out(unique.dois, hcx_list)
  sensitivity_matrix <- matrix(sensitivity_vector, nrow = length(unique.dois), byrow = TRUE)
  rownames(sensitivity_matrix) <- unique.dois
  #bind DOI's to other parameters of interest for analysis
  sensitivity_tbl <- rownames_to_column(as.data.frame(sensitivity_matrix), var = c("doi")) %>%
    rename(hcx = V1)
  # join to other parameters of interest
  sensitivity_df <- left_join(sensitivity_tbl, filtered_data, by = "doi") %>% 
    dplyr::select(authors, year, Species, dose_new, 
                  hcx, acute.chronic_f, bio_f, lvl2_f,
                  size.length.um.used.for.conversions, doi) %>% 
    distinct(doi, authors, year, hcx, Species, acute.chronic_f,
             size.length.um.used.for.conversions) %>% 
    mutate(authoryear = paste(authors, "et. al ", year)) %>% 
    mutate(hcx = replace_na(hcx, 0)) %>% #studies with n_species < 5 will get a 0
    mutate(authoryear = fct_reorder(authoryear, hcx, na.rm = FALSE)) %>% 
    mutate(diff = (hcx - filtered_data_hcx)/filtered_data_hcx,
             tier = as.character(tier_input), #annotate for full dataset
           ERM = as.character(ERM_input),
           environment = as.character(environment_input)) #annotate for full dataset
  
  sensitivity_summary <- sensitivity_df %>% 
    group_by(doi, authoryear, diff, hcx) %>% 
    summarise(species_multiple = paste(unique(Species), collapse = ", "),
              .groups = "keep") %>% 
    ungroup() %>% 
    arrange(desc(hcx)) %>% 
    mutate(hcx = case_when(hcx == 0 ~ NA,
                           TRUE ~ hcx),
           diff = case_when(diff == -1 ~ NA,
                            TRUE ~ diff)) %>% 
    mutate(sufficient_species = case_when(!is.na(hcx) ~ "sufficient",
                                          is.na(hcx) ~ "insufficient"),
           ERM = as.character(ERM_input),
           environment = as.character(environment_input),
           tier = as.character(tier_input)) #annotate for full dataset))
 
   return(list(sensitivity_df = sensitivity_df, 
               sensitivity_summary = sensitivity_summary))
}

# Tier 3/4 function
leave_one_out_tier3_4 <- function(filtered_data, hcx_num, ERM_input, tier_input, environment_input) {
  hcx_list <- list(hcx = hcx_num)
  #base HCx
  filtered_data_hcx <- SSD_function_t3_4(filtered.data = filtered_data, hcx_num)
  filtered_data_hcx <- filtered_data_hcx$hcx_est[1] 
  unique.dois <- unique(filtered_data$doi)
  # Create the leave-one-out function with your filtered data
  leave_one_out <- create_leave_one_out_function_t3_4(filtered_data)
  # Apply the leave-one-out function
  sensitivity_vector <- leave_one_out(unique.dois, hcx_list)
  sensitivity_matrix <- matrix(sensitivity_vector, nrow = length(unique.dois), byrow = TRUE)
  rownames(sensitivity_matrix) <- unique.dois
  #bind DOI's to other parameters of interest for analysis
  sensitivity_tbl <- rownames_to_column(as.data.frame(sensitivity_matrix), var = c("doi")) %>%
    rename(hcx = V1)
  # join to other parameters of interest
  sensitivity_df <- left_join(sensitivity_tbl, filtered_data, by = "doi") %>% 
    dplyr::select(authors, year, Species, dose_new, 
                  hcx, acute.chronic_f, bio_f, lvl2_f,
                  size.length.um.used.for.conversions, doi) %>% 
    distinct(doi, authors, year, hcx, Species, acute.chronic_f,
             size.length.um.used.for.conversions) %>% 
    mutate(authoryear = paste(authors, "et. al ", year)) %>% 
    mutate(hcx = replace_na(hcx, 0)) %>% #studies with n_species < 5 will get a 0
    mutate(authoryear = fct_reorder(authoryear, hcx, na.rm = FALSE)) %>% 
    mutate(diff = (hcx - filtered_data_hcx)/filtered_data_hcx,
           tier = as.character(tier_input), #annotate for full dataset
           ERM = as.character(ERM_input),
           environment = as.character(environment_input)) #annotate for full dataset)
  
  sensitivity_summary <- sensitivity_df %>% 
    group_by(doi, authoryear, diff, hcx) %>% 
    summarise(species_multiple = paste(unique(Species), collapse = ", "),
              .groups = "keep") %>% 
    ungroup() %>% 
    arrange(desc(hcx)) %>% 
    mutate(hcx = case_when(hcx == 0 ~ NA,
                           TRUE ~ hcx),
           diff = case_when(diff == -1 ~ NA,
                            TRUE ~ diff)) %>% 
    mutate(sufficient_species = case_when(!is.na(hcx) ~ "sufficient",
                                          is.na(hcx) ~ "insufficient"),
           ERM = as.character(ERM_input),
           environment = as.character(environment_input),
           tier = as.character(tier_input)) #annotate for full dataset))
 
   return(list(sensitivity_df = sensitivity_df, 
               sensitivity_summary = sensitivity_summary))
}

```
### Perform Sensitivity Analyses
```{r message=FALSE, warning=FALSE, include=FALSE}
#### Freshwater #####
#Tissue Translocation Thresholds
tier1_sensitivity_tissue_freshwater <- leave_one_out_tier_1(filtered.data.small.default_t1.2 %>%
                                                   filter(environment == "Freshwater"), hcx = 5,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 1", 
                                                   environment_input = "Freshwater")
tier2_sensitivity_tissue_freshwater <- leave_one_out_tier2(filtered.data.small.default_t1.2 %>%
                                                   filter(environment == "Freshwater"), 5,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 2", 
                                                   environment_input = "Freshwater")
tier3_sensitivity_tissue_freshwater <- leave_one_out_tier3_4(filtered.data.small.default_t3.4 %>%
                                                   filter(environment == "Freshwater"), 5,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 3", 
                                                   environment_input = "Freshwater")
tier4_sensitivity_tissue_freshwater <- leave_one_out_tier3_4(filtered.data.small.default_t3.4 %>%
                                                   filter(environment == "Freshwater"), 10,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 4", 
                                                   environment_input = "Freshwater")

#Food Dilution Thresholds
tier1_sensitivity_food_freshwater <- leave_one_out_tier_1(filtered.data.large.default_t1.2 %>%
                                                   filter(environment == "Freshwater"), 5,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 1", 
                                                   environment_input = "Freshwater")
tier2_sensitivity_food_freshwater <- leave_one_out_tier2(filtered.data.large.default_t1.2 %>%
                                                   filter(environment == "Freshwater"), 5,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 2", 
                                                   environment_input = "Freshwater")
tier3_sensitivity_food_freshwater <- leave_one_out_tier3_4(filtered.data.large.default_t3.4 %>%
                                                   filter(environment == "Freshwater"), 5,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 3", 
                                                   environment_input = "Freshwater")
tier4_sensitivity_food_freshwater <- leave_one_out_tier3_4(filtered.data.large.default_t3.4 %>%
                                                   filter(environment == "Freshwater"), 10,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 4", 
                                                   environment_input = "Freshwater")

#### Marine #####
#Tissue Translocation Thresholds
tier1_sensitivity_tissue_marine <- leave_one_out_tier_1(filtered.data.small.default_t1.2 %>%
                                                   filter(environment == "Marine"), hcx = 5,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 1", 
                                                   environment_input = "Marine")
tier2_sensitivity_tissue_marine <- leave_one_out_tier2(filtered.data.small.default_t1.2 %>%
                                                   filter(environment == "Marine"), 5,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 2", 
                                                   environment_input = "Marine")
tier3_sensitivity_tissue_marine <- leave_one_out_tier3_4(filtered.data.small.default_t3.4 %>%
                                                   filter(environment == "Marine"), 5,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 3", 
                                                   environment_input = "Marine")
tier4_sensitivity_tissue_marine <- leave_one_out_tier3_4(filtered.data.small.default_t3.4 %>%
                                                   filter(environment == "Marine"), 10,
                                                   ERM_input = "Tissue Translocation", tier_input = "Tier 4", 
                                                   environment_input = "Marine")

#Food Dilution Thresholds
tier1_sensitivity_food_marine <- leave_one_out_tier_1(filtered.data.large.default_t1.2 %>%
                                                   filter(environment == "Marine"), 5,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 1", 
                                                   environment_input = "Marine")
tier2_sensitivity_food_marine <- leave_one_out_tier2(filtered.data.large.default_t1.2 %>%
                                                   filter(environment == "Marine"), 5,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 2", 
                                                   environment_input = "Marine")
tier3_sensitivity_food_marine <- leave_one_out_tier3_4(filtered.data.large.default_t3.4 %>%
                                                   filter(environment == "Marine"), 5,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 3", 
                                                   environment_input = "Marine")
tier4_sensitivity_food_marine <- leave_one_out_tier3_4(filtered.data.large.default_t3.4 %>%
                                                   filter(environment == "Marine"), 10,
                                                   ERM_input = "Food Dilution", tier_input = "Tier 4", 
                                                   environment_input = "Marine")
```

### Export Data
```{r}
leave_one_out_df <- rbind(tier1_sensitivity_tissue_freshwater$sensitivity_summary,
                          tier2_sensitivity_tissue_freshwater$sensitivity_summary,
                          tier3_sensitivity_tissue_freshwater$sensitivity_summary,
                          tier4_sensitivity_tissue_freshwater$sensitivity_summary,
                          tier1_sensitivity_food_freshwater$sensitivity_summary,
                          tier2_sensitivity_food_freshwater$sensitivity_summary,
                          tier3_sensitivity_food_freshwater$sensitivity_summary,
                          tier4_sensitivity_food_freshwater$sensitivity_summary,
                          tier1_sensitivity_tissue_marine$sensitivity_summary,
                          tier2_sensitivity_tissue_marine$sensitivity_summary,
                          tier3_sensitivity_tissue_marine$sensitivity_summary,
                          tier4_sensitivity_tissue_marine$sensitivity_summary,
                          tier1_sensitivity_food_marine$sensitivity_summary,
                          tier2_sensitivity_food_marine$sensitivity_summary,
                          tier3_sensitivity_food_marine$sensitivity_summary,
                          tier4_sensitivity_food_marine$sensitivity_summary)

write.csv(leave_one_out_df,
          "../output/data/leave_one_out.csv")
```
```{r}
### start here if not wanting to run previous chunk (can take a long time)
leave_one_out_df <- read.csv("../output/data/leave_one_out.csv")
```


### Plot
```{r}
library(ggallin)

leave_one_out_ggplot <- leave_one_out_df %>% 
  drop_na() %>% 
  mutate(diff = diff + 0.0001) %>% 
#  mutate(logdiff = log10(diff))
  # group_by(environment, ERM, tier
  #          ) %>% 
  # summarize(minDiff = min(diff, na.rm = T),
  #           maxDiff = max(diff, na.rm = T)) %>% 
  # pivot_longer(cols = contains("diff")) %>% 
  # rename(diffMagnitude = name,
  #        diff = value) %>% 
  # left_join(leave_one_out_df %>% select(diff, hcx, doi, authoryear, species_multiple),
  #           by = "diff") %>% 
  ggplot(aes(x = diff, y = tier, color = environment,
             text = paste0("%Difference: ", scales::percent(diff, 0.1, big.mark = ","),
                                              "<br>HCx: ",scientific(hcx, 3), " particles/L",
                                              "<br>Study: ", authoryear,
                                              "<br>Species: " ,species_multiple,
                                              "<br>doi: ", doi)
             )) +
  geom_jitter(width = 0, height = 0.3, alpha = 0.5) +
#  geom_point(alpha = 0.7) +
#  geom_histogram() +
 # geom_boxplot() +
   # geom_text_repel(aes(label = species_multiple),
   #                size = 3,
   #                nudge_x = 0.25,
   #                force = 4,
   #                color = "black",
   #                direction = "y",
   #                # Jitter on the y-axis
   #                max.overlaps = Inf,
   #                label.padding = 1,
   #                fontface = "italic") +
 # geom_line() +
  #geom_vline(xintercept = 0.00001, alpha = 0.5, color = "grey60") +
  scale_x_continuous(trans = pseudo_log_trans(base = 10), 
                     breaks = c(-1, 0, 1, 10, 100), 
                     limits = c(-1, 110), 
                     labels = scales::percent_format(accuracy = 1, big.mark = ",")) +
#  scale_x_log10() +
  
  xlab("% Difference") +
  theme_minimal(base_size = 13) +
 theme( plot.title = element_text(hjust = 0.5, size = 14),     # Center the main title
        strip.text = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption = element_text(hjust = 0.5),   # Center the caption
        axis.title.x = element_text(hjust = 0.5, size = 14),  # Center the x-axis title
        axis.text.x =  element_text(size = 11),
        axis.text.y = element_text(size = 14),
        axis.title.y = element_text(vjust = 0.5, size = 18)) +   # Center the y-axis title (vertically))   # Center the subtitle)
  theme(legend.position = "none",
        axis.title.y = element_blank()) +
  facet_grid(environment ~ ERM)
  #facet_wrap(~environment + ERM)

ggsave(plot = leave_one_out_ggplot,
       filename = "../output/Manuscript_Figs/leave_one_out.jpg",
      dpi = 300,
      width = 10, height = 7, units = "in")

leave_one_out_ggplot
```
#### Plotly
```{r}
leave_one_out_ggplotly <- ggplotly(leave_one_out_ggplot, tooltip = "text")

require(htmlwidgets)

# Save the plot as an HTML file
saveWidget(leave_one_out_ggplotly , file = "../output/Manuscript_Figs/leave_one_out_ggplotly.html")
```





## Monte Carlo Alignments
### Parameter histograms
```{r}
n_sim <- 100000 #histogram data points
# particle properties
R.ave.water.marine <- 0.77 # average length to width ratio of microplastics in marine environment (Kooi et al. 2021)
R.ave.water.marine.sd = 0.29 #Tablse s3. Marine surface water
R.ave.water.marine_samples <- rnorm(n_sim, mean = R.ave.water.marine, sd = R.ave.water.marine.sd)

R.ave.water.freshwater <- 0.67 # average length to width ratio of microplastics in freshwater environment (Kooi et al. 2021)
R.ave.water.freshwater.sd = 0.28 #Tablse s3. freshwater surface water
R.ave.water.freshwater_samples <- rnorm(n_sim, mean = R.ave.water.freshwater, sd = R.ave.water.freshwater.sd)

R.ave.sediment.marine <- 0.75 # average length to width ratio of microplastics in marine environment (Kooi et al. 2021)
R.ave.sediment.marine.sd = 0.30 #Tablse s3. Marine surface sediment
R.ave.sediment.marine_samples <- rnorm(n_sim, mean = R.ave.sediment.marine, sd = R.ave.sediment.marine.sd)

R.ave.sediment.freshwater <- 0.70 # average length to width ratio of microplastics in freshwater environment (Kooi et al. 2021)
R.ave.sediment.freshwater.sd = 0.33 #Tablse s3. freshwater surface sediment
R.ave.sediment.freshwater_samples <- rnorm(n_sim, mean = R.ave.sediment.freshwater, sd = R.ave.sediment.freshwater.sd)

#### MARINE ####
p.ave.marine = 1.10 #average density in marine surface water
p.ave.sd.marine = 0.14 #Tablse s3. Marine surfac water
p.ave.marine_samples <- rnorm(n_sim, mean = p.ave.marine, sd = p.ave.sd.marine)

# Alignment properties
alpha.marine = 2.07 #table s4 for marine surface water. length
alpha.sd.marine = 0.03 #table s4 for marine surface water. lengthj
alpha.marine_samples <- rnorm(n_sim, mean = alpha.marine, sd = alpha.sd.marine)

# define parameters for power law coefficients
a.sa.marine = 1.50 #marine surface area power law
a.sa.sd.marine = 0.009 #marine surface water surface area power law - table s4
a.sa.marine_samples <- rnorm(n_sim, mean = a.sa.marine, sd = a.sa.sd.marine)

a.v.marine = 1.48 #a_V for marine surface water volume
a.v.sd.marine = 0.063
a.v.marine_samples <- rnorm(n_sim, mean = a.v.marine, sd = a.v.sd.marine)

a.m.marine = 1.32 # upper limit fora_m for mass for marine surface water in table S4 
a.m.sd.marine = 0.009
a.m.marine_samples <- rnorm(n_sim, mean = a.m.marine, sd = a.m.sd.marine)

a.ssa.marine = 1.98 # A_SSA for marine surface water
a.ssa.sd.marine = 0.297
a.ssa.marine_samples <- rnorm(n_sim, mean = a.ssa.marine, sd = a.ssa.sd.marine)

#### FRESHWATER ####
p.ave.freshwater = 1.04 #average density in freshwater surface water
p.ave.sd.freshwater = 0.12 #Tablse s3. freshwater surfac water
p.ave.freshwater_samples <- rnorm(n_sim, mean = p.ave.freshwater, sd = p.ave.sd.freshwater)

# Alignment properties
alpha.freshwater = 2.64 #table s4 for freshwater surface water. length
alpha.sd.freshwater = 0.01 #table s4 for freshwater surface water. lengthj
alpha.freshwater_samples <- rnorm(n_sim, mean = alpha.freshwater, sd = alpha.sd.freshwater)

# define parameters for power law coefficients
a.sa.freshwater = 2.00 #freshwater surface area power law
a.sa.sd.freshwater = 0.065 #freshwater surface water surface area power law - table s4
a.sa.freshwater_samples <- rnorm(n_sim, mean = a.sa.freshwater, sd = a.sa.sd.freshwater)

a.v.freshwater = 1.68 #a_V for freshwater surface water volume
a.v.sd.freshwater = 0.081
a.v.freshwater_samples <- rnorm(n_sim, mean = a.v.freshwater, sd = a.v.sd.freshwater)

a.m.freshwater = 1.65 # upper limit fora_m for mass for freshwater surface water in table S4 
a.m.sd.freshwater = 0.071
a.m.freshwater_samples <- rnorm(n_sim, mean = a.m.freshwater, sd = a.m.sd.freshwater)

a.ssa.freshwater = 2.71 # A_SSA for freshwater surface water
a.ssa.sd.freshwater = 0.009
a.ssa.freshwater_samples <- rnorm(n_sim, mean = a.ssa.freshwater, sd = a.ssa.sd.freshwater)

# Coefficients
beta_log10_body_length <- 0.9341
body_length_intercept <- 1.1200
# Standard errors for these coefficients
se_beta_log10_body_length <- 0.1376  # SE generated from Jams et al R code (not rpoerted in paper or SI!) (https://github.com/fmwindsor/plastic-allometry)
se_body_length_intercept <- 0.3222      # SE generated from Jams et al R code (not rpoerted in paper or SI!) (https://github.com/fmwindsor/plastic-allometry)
#data
sim_beta_log10_body_length_samples <- rnorm(n_sim, mean = beta_log10_body_length, sd = se_beta_log10_body_length)
sim_body_length_intercept_samples <- rnorm(n_sim, mean = body_length_intercept, sd = se_body_length_intercept)

#### Tissue translocation length ##
# Parameters from the logistic regression# See scripts/translocation/translocation.Rmd for model
beta_0 <- 1.308344# simple$coefficients[[1]]  # 1.24  # Intercept
beta_1 <- -0.01468148 # simple$coefficients[[2]]   #-0.014  # Slope for particle length
se_beta_0 <- 0.3963612 # simple_summary$coefficients[[1,2]]  # 0.40  # SE of intercept
se_beta_1 <- 0.006657993 #simple_summary$coefficients[[2,2]]  # SE of slope

# Simulate beta_0 and beta_1
sim_beta_0 <- rnorm(n_sim * 1.2, mean = beta_0, sd = se_beta_0)
sim_beta_1 <- rnorm(n_sim * 1.2, mean = beta_1, sd = se_beta_1)

# Calculate X50 for each simulation
sim_X50 <- -sim_beta_0 / sim_beta_1

#truncate distribution to not fall below 0
upper.tissue.trans.size.um_samples <- sim_X50 %>% data.frame() %>% filter(.>0) %>% slice(1:n_sim)
upper.tissue.trans.size.um_samples <- as.numeric(upper.tissue.trans.size.um_samples$.)

#define param values
param_values <- data.frame(
  a.l.marine = alpha.marine_samples,
  a.sa.marine = a.sa.marine_samples,
  a.v.marine = a.v.marine_samples,
  a.m.marine = a.m.marine_samples,
  a.ssa.marine = a.ssa.marine_samples,
  R.ave.marine = R.ave.water.marine_samples,
  a.l.freshwater = alpha.freshwater_samples,
  a.sa.freshwater = a.sa.freshwater_samples,
  a.v.freshwater = a.v.freshwater_samples,
  a.m.freshwater = a.m.freshwater_samples,
  a.ssa.freshwater = a.ssa.freshwater_samples,
  R.ave.freshwater = R.ave.water.freshwater_samples,
#  R.ave.sediment.marine = R.ave.sediment.marine_samples,
#  R.ave.sediment.freshwater = R.ave.sediment.freshwater_samples,
  body.length.beta = sim_beta_log10_body_length_samples,
  body.length.intercept = sim_body_length_intercept_samples,
  upper.tissue.size.um =  upper.tissue.trans.size.um_samples
)
```
Save summary stats and params in a table for the SI.
```{r}
summaries <- param_values %>%
  pivot_longer(cols = everything(), names_to = "Parameter", values_to = "Value") %>%
  group_by(Parameter) %>%
  summarise(
    mean = sprintf("%.3g", mean(Value, na.rm = TRUE)),
    sd = sprintf("%.3g", sd(Value, na.rm = TRUE)),
    median = sprintf("%.3g", median(Value, na.rm = TRUE)),
    lower_95_ci = sprintf("%.3g", quantile(Value, 0.025, na.rm = TRUE)),
    upper_95_ci = sprintf("%.3g", quantile(Value, 0.975, na.rm = TRUE))
  )

write.csv(summaries, "../output/data/MC_params.csv", row.names = FALSE)

summaries
```


Draw histograms for publication
 
```{r}
MC_param_histograms <- param_values %>% 
  pivot_longer(cols = everything()) %>% 
  mutate(name = factor(name, levels = c("a.l.marine", "a.sa.marine", "a.v.marine",
                                        "a.m.marine", "a.ssa.marine", "R.ave.marine",
                                        "a.l.freshwater", "a.sa.freshwater", "a.v.freshwater",
                                        "a.m.freshwater", "a.ssa.freshwater",
                                        "R.ave.freshwater",
                                        "body.length.beta",
                                        "body.length.intercept",
                                        "upper.tissue.size.um"))) %>% 
  ggplot(aes(x = value, fill = name)) +
  geom_histogram(bins = 350, linewidth = 0.10) +
  scale_x_log10()+
#  xlim(c(1,1000))+
  labs(#title = "Distribution of Simulated X50 Values",
       x = "Value",
       y = "Relative Frequency") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        plot.title = element_blank(),
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption = element_text(hjust = 0.5),   # Center the caption
        axis.title.x = element_text(hjust = 0.5, size = 16, face = "bold"),  # Center the x-axis title
        axis.text.x = element_text(size = 11),
        axis.text.y = element_blank(),
       # axis.text = element_text(size = 16),
        axis.title.y = element_text(vjust = 0.5, size = 16, face = "bold"),
       strip.text = element_text(size = 16, face = "bold", family = "serif")  # Customize facet title size
       )  + # Center the y-axis title
  facet_wrap(~name, scales = "free",
             ncol = 6)

MC_param_histograms

ggsave(filename = "MC_param_histograms.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = MC_histograms, width = 9, height = 8, units = "in")
```


 NOTE: this is done in scripts/monte carlo/Master_Data_Tidying_Monte_Carlo.R. The reason is that the data prep scripts are extremely complicated, and preserving every nuance with perfect fidelity through copying into this markdown script has proven impossible. Just import the final RDS file generated from that script.
 
```{r}
MC_results <- readRDS("monte carlo/output/MC_results_sobol.rds")
summary_stats_base_thresholds <- readRDS("monte carlo/output/summary_stats_base_thresholds_sobol.rds")
```
 
```{r}
aoc_MC <- readRDS("monte carlo/output/aoc_MC.rds")
n_sim <- aoc_MC$n_sim[[1]]
print(paste("Number of MC Simulations:", n_sim))
```



### Alignment Monte-Carlo Simulation
#### Test code with static values

```{r eval=FALSE, include=FALSE}
# Compare the datasets to find if they are identical
identical_datasets <- identical(aoc_d_simple, aoc_final_simple)

identical_datasets
# If the datasets are not identical, check where they differ
# Create a logical matrix indicating where elements differ
  differences <- aoc_d_simple != aoc_final_simple
  
 # Assuming 'differences' is your logical matrix with TRUE/FALSE/NA values
# Set NAs to FALSE (if NA means no difference for your case)
differences[is.na(differences)] <- FALSE

# Get rows and columns indices where differences are TRUE
diff_indices <- which(differences, arr.ind = TRUE)

# Get unique rows and columns involved in differences
diff_rows <- unique(diff_indices[, "row"])
diff_cols <- unique(diff_indices[, "col"])

# If differences are found, print them out
if (length(diff_rows) > 0) {
  cat("Differences found in the following rows and columns:\n")
  for (i in seq_along(diff_rows)) {
    for (j in seq_along(diff_cols)) {
      if (differences[diff_rows[i], diff_cols[j]]) {  # Check if TRUE
        # Using column names instead of indices
        cat(sprintf("Difference at Row: %d, Column: %s\n",
                    diff_rows[i], colnames(differences)[diff_cols[j]]))
      }
    }
  }
} else {
  cat("No differences found.\n")
}

 aoc_d_simple[diff_rows,]
```

```{r}
left_join(aoc_d_simple %>% select(c(rowid, particles.mL.ox.stress, particles.mL.food.dilution)),
          aoc_final %>% select(c(rowid, particles.mL.ox.stress, particles.mL.food.dilution)),
          by = "rowid", suffix = c(".x", ".y")) %>% 
  mutate(ox.stress.ratio = particles.mL.ox.stress.x / particles.mL.ox.stress.y,
         food.ratio = particles.mL.food.dilution.x / particles.mL.food.dilution.y) %>% 
  filter(ox.stress.ratio != 1)
```

```{r}
left_join(aoc_d_simple, aoc_final_simple, by ="rowid")
```

### Threshold distributions
```{r}
# Extract and combine base_thresholds for each environment
all_thresholds_marine <- map(MC_results, ~ .x$base_thresholds$marine) %>% 
  bind_rows(.id = "simulation_id")

all_thresholds_freshwater <- map(MC_results, ~ .x$base_thresholds$freshwater) %>% 
  bind_rows(.id = "simulation_id")

all_thresholds_freshwater_marine <- map(MC_results, ~ .x$base_thresholds$freshwater_marine) %>% 
  bind_rows(.id = "simulation_id")

# Combine marine and freshwater data into one data frame with an additional "Environment" column
all_thresholds_combined <- bind_rows(
  mutate(all_thresholds_marine, Environment = "Marine"),
  mutate(all_thresholds_freshwater, Environment = "Freshwater"),
  mutate(all_thresholds_freshwater_marine, Environment = "freshwater_marine"),
  .id = "simulation_id"
)

# Pivot data longer if the data structure requires it
# Assuming that your data might already be in a wide format and needs to be made long
all_thresholds_long <- all_thresholds_combined %>%
  pivot_longer(
    cols = -c(Tier, simulation_id, Environment),
    names_to = "Metric",
    values_to = "Value"
  )

# Calculate summary statistics
summary_stats_base_thresholds <- all_thresholds_long %>%
  group_by(Tier, Environment, Metric) %>%
  summarise(
    Mean = mean(Value, na.rm = TRUE),
    Median = median(Value, na.rm = TRUE),
    Std_Dev = sd(Value, na.rm = TRUE),
    N_sim = n(),
    .groups = 'drop'
  )

### Ggplot of SSD Tier Thresholds
# Prepare the data by calculating ERM and filtering
prepared_data <- all_thresholds_long %>%
  mutate(ERM = case_when(
    grepl("Tissue", Metric) ~ "Tissue Translocation",
    grepl("Food", Metric) ~ "Food Dilution"
  )) %>%
  filter(
    grepl("Default", Metric),
    Environment == "Marine"
  )

# Calculate median values for each group
median_data <- prepared_data %>%
  group_by(Tier, ERM) %>%
  summarise(Median = median(Value), .groups = 'drop')

# Assign specific colors based on Tier levels
tier_colors <- setNames(c("#e2efd9", "#f9e39c", "#f0a95f", "#f0514b"), levels(prepared_data$Tier))

MC_histograms_base <- ggplot(prepared_data, aes(x = Value)) +
  geom_density(aes(color = Tier), size = 1) +  # Map 'Tier' for color
  geom_histogram(aes(y = ..density.., fill = Tier), bins = 150, color = "black", alpha = 0.6, linewidth = 0.05) +  # Map 'Tier' for fill
  geom_vline(data = median_data, aes(xintercept = Median),
             linetype = "dotted", color = "black", linewidth = 1.2) +
#  geom_text(data = median_data, aes(x = Median, y = 0, label = paste0("Median:", scientific(Median, 2))),
        #    hjust = +1.5, vjust = -1.5, color = "black", size = 6, fontface = "italic") +
  xlab("Particles/L") +
  scale_x_log10(labels = scales::comma) +
  facet_wrap(~ Tier + ERM, scales = "free", ncol = 2) +
  scale_fill_manual(values = tier_colors) +  # Apply manual colors for fill
  scale_color_manual(values = tier_colors)  # Apply manual colors for lines

library(ggdark)
MC_histograms_dark <- MC_histograms_base +
  dark_theme_bw(base_size = 20) +
  theme(
    strip.background = element_blank(),
    strip.placement = "outside",
    legend.position = "none",
    strip.text = element_blank(),  # This hides the facet wrap titles
    #  strip.text = element_text(face = "bold", size = 16, margin = margin(t = 1, b = 1)),
    panel.spacing = unit(0.1, "lines"),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank()
  )

MC_histograms_light <- MC_histograms_base +
  theme_bw(base_size = 20) +
  theme(
    strip.background = element_blank(),
    strip.placement = "outside",
    legend.position = "none",
    strip.text = element_blank(),  # This hides the facet wrap titles
 #  strip.text = element_text(face = "bold", size = 16, margin = margin(t = 1, b = 1)),
    panel.spacing = unit(0.1, "lines"),
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank()
  )


ggsave("../output/Manuscript_Figs/MC_histograms.png",
       MC_histograms_light, 
      dpi = 300,
      width = 12, height = 9, units = "in")

ggsave("../output/presentation_Figs/MC_histograms.png",
       MC_histograms_dark, 
       dpi = 300,
       width = 10, height = 5,
       units = "in")

MC_histograms_light

```



### CoV Determination
```{r eval=FALSE, include=FALSE}
## STEP 1: 
# Create a dataframe from the list
results_df <- do.call(rbind, lapply(MC_results, function(x) {
  data.frame(
    unique_id = x$unique_id,
    particles_L_ox_stress = x$particles_mL_ox_stress *1000,
    particles_L_food_dilution = x$particles_mL_food_dilution * 1000
  )
}))

# Convert factors to numeric if necessary
results_df$particles_L_ox_stress <- as.numeric(as.character(results_df$particles_L_ox_stress))
results_df$particles_L_food_dilution <- as.numeric(as.character(results_df$particles_L_food_dilution))

skimr::skim(results_df)
```


```{r eval=FALSE, include=FALSE}
## Step 2:
# Calculate CoV
cov_results <- results_df %>%
  group_by(unique_id) %>%
  summarise(sd_particles_L_ox_stress = sd(particles_L_ox_stress, na.rm = TRUE),
            mean_particles_L_ox_stress = mean(particles_L_ox_stress, na.rm = TRUE),
            median_particles_L_ox_stress = median(particles_L_ox_stress, na.rm = TRUE),
            CoV_ox_stress = sd_particles_L_ox_stress / mean_particles_L_ox_stress,
            #food dilution
            sd_particles_L_food_dilution = sd(particles_L_food_dilution, na.rm = TRUE),
            mean_particles_L_food_dilution = mean(particles_L_food_dilution, na.rm = TRUE),
            median_particles_L_food_dilution = median(particles_L_food_dilution, na.rm = TRUE),
            CoV_food_dilution = sd_particles_L_food_dilution / mean_particles_L_food_dilution
  )

# View the results
print(cov_results)

skimr::skim(cov_results)
```

```{r eval=FALSE, include=FALSE}
# Step 3: merge with full dataset and deterministic dataset
aoc_MC <- merge(aoc_final, cov_results, by = "unique_id", all.x = TRUE)
aoc_MC <- left_join(aoc_MC, 
                    aoc_final %>% ungroup() %>%  
                      select(c(unique_id, particles.mL.food.dilution, particles.mL.ox.stress)) %>%
                      mutate(particles_L_food_dilution_deterministic = particles.mL.food.dilution * 1000,
                             particles_L_ox_stress_deterministic = particles.mL.ox.stress * 1000),
                    by = "unique_id"
                    ) #%>% 
   #filter(size.length.um.used.for.conversions >= x1M_set) %>% #alignments not valid below 1 um, so filter them before they become problems later

# summary stats to ensure MC was succesful 
aoc_MC %>% 
  select(c(particles_L_ox_stress_deterministic, median_particles_L_ox_stress,
           particles_L_food_dilution_deterministic, median_particles_L_food_dilution)) %>% 
  mutate(ox_stress_ratio = particles_L_ox_stress_deterministic / median_particles_L_ox_stress,
         food_dilution_ratio = particles_L_food_dilution_deterministic / median_particles_L_food_dilution)
  
```

### IMPORT DATA
```{r}
getwd()
aoc_MC <- readRDS("monte carlo/output/aoc_MC_sobol.rds")

results_df <- readRDS("monte carlo/output/results_df_sobol.rds")
```


```{r}
#define limits
min_val <- min(aoc_MC$CoV_food_dilution, na.rm = TRUE)
max_val <- max(aoc_MC$CoV_food_dilution, na.rm = TRUE)

# You may want to add some padding around the min and max
pad <- (max_val - min_val) * 0.05
xlims <- c(min_val - pad, max_val + pad)

hist_cv_food <- aoc_MC %>% 
  filter(Species != "Algae",
         ingestible == "ingestible") %>% 
  ggplot(aes(x = CoV_food_dilution, fill = polydispersity)) +
  geom_histogram(position = "identity", alpha = 0.5) +
 # xlim(xlims) +  # Set x limits
  scale_x_log10() +
  xlab("Coefficient of Variation (unitless)") +
  ylab("Toxicity Data Points") +
  fill.type +
  theme.light #+
  #theme(axis.title.x = element_blank())

hist_cv_ox <- aoc_MC %>% 
  ggplot(aes(x = CoV_ox_stress, fill = polydispersity)) +
  geom_histogram(position = "identity", alpha = 0.5) +
  fill.type +
  scale_x_log10() +
 # xlim(xlims) +  # Set x limits
  xlab("Coefficient of Variation (unitless)") +
  ylab("Toxicity Data Points") +
  theme.light +
  theme(legend.position = "none",
        axis.title.y = element_blank())

CoV_plots <- ggarrange(hist_cv_food, hist_cv_ox,
                       labels = c("A", "B"),
                       ncol = 2,
                       common.legend = TRUE, legend = "top")

ggsave(filename = "CoV_plots.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = CoV_plots, width = 10, height = 8, units = "in")

CoV_plots
```

```{r}
#define limites
min_val <- min(aoc_MC$CoV_food_dilution, na.rm = TRUE)
max_val <- max(aoc_MC$CoV_food_dilution, na.rm = TRUE)

# You may want to add some padding around the min and max
pad <- (max_val - min_val) * 0.05
xlims <- c(min_val - pad, max_val + pad)

points_cv_food <- aoc_MC %>% 
  ggplot(aes(x = CoV_food_dilution, y = size.length.um.used.for.conversions, color = polydispersity)) +
  geom_point() +
  xlim(xlims) +  # Set x limits
  color.type +
  theme_minimal()

points_cv_ox <- aoc_MC %>% 
  ggplot(aes(x = CoV_ox_stress, y = size.length.um.used.for.conversions, color = polydispersity)) +
  geom_point() +
 # xlim(xlims) +  # Set x limits
  color.type +
  theme_minimal()
  theme(legend.position = "none")

ggarrange(points_cv_food, points_cv_ox,
          nrow = 2,
          common.legend = TRUE, legend = "right")
```


```{r}
mouth_lm_food <- lm(data = aoc_MC, CoV_food_dilution ~ max.size.ingest.um * polydispersity)
summary(mouth_lm_food)
```
```{r}
mouth_lm_ox_stress <- lm(data = aoc_MC, CoV_ox_stress ~ max.size.ingest.um * polydispersity)
summary(mouth_lm_ox_stress)
```


```{r}
mouth_cv_food <- aoc_MC %>% 
    ggplot(aes(x = CoV_food_dilution, y = max.size.ingest.um, color = polydispersity)) +
  geom_point(alpha = 0.75, size = 2.1) +
  geom_smooth(method = "lm", se = T, aes(group = 1), alpha = 0.7, color = "darkgreen", fill = "darkgreen", linetype = "dashed") +  # A single regression line for all data
  ggpmisc::stat_poly_eq(aes(label = paste(..eq.label..), group = 1),
                        color = "darkgreen",
                        formula = y ~ x, 
                        method = "lm",
                        label.x = 0.1,
                        label.y = 0.4,  # Position at the top, adjust if necessary
                        parse = TRUE) +
   ggpmisc::stat_poly_eq(aes(label = paste(..rr.label..), group = 1),
                        color = "darkgreen",
                        formula = y ~ x, 
                        method = "lm",
                        label.x = 0.1,
                        label.y = 0.25,  # Position at the top, adjust if necessary
                        parse = TRUE) +
    ggpmisc::stat_poly_eq(aes(label = ..p.value.label.., group = 1),
                        color = "darkgreen",
                        formula = y ~ x, 
                        method = "lm",
                        label.x = 0.1,
                        label.y = 0.1,  # Position at the top, adjust if necessary
                        parse = TRUE) +
    xlab("Coefficient of Variation (unitless)") +
  ylab("Organism Mouth Size Opening (um) for Toxicity Datapoint") +
  scale_y_log10() +
  scale_x_log10() +
  xlim(xlims) +  # Set x limits
  color.type +
  theme.light +
  theme(legend.position = "none",
        axis.title.y = element_blank(),
        axis.title.x = element_blank()
        ) +
   guides(fill = guide_legend(title = NULL), color = guide_legend(title = NULL))  # Remove legend titles

mouth_cv_ox <- aoc_MC %>% 
  ggplot(aes(x = CoV_ox_stress, y = max.size.ingest.um, color = polydispersity)) +
   geom_point(alpha = 0.75, size = 2.1) +
  geom_smooth(method = "lm", se = T, aes(group = 1), alpha = 0.7, color = "darkgreen", fill = "darkgreen", linetype = "dashed") +  # A single regression line for all data
  ggpmisc::stat_poly_eq(aes(label = paste(..eq.label..), group = 1),
                        color = "darkgreen",
                        formula = y ~ x, 
                        method = "lm",
                        label.x = 0.1,
                        label.y = 0.4,  # Position at the top, adjust if necessary
                        parse = TRUE) +
   ggpmisc::stat_poly_eq(aes(label = paste(..rr.label..), group = 1),
                        color = "darkgreen",
                        formula = y ~ x, 
                        method = "lm",
                        label.x = 0.1,
                        label.y = 0.25,  # Position at the top, adjust if necessary
                        parse = TRUE) +
    ggpmisc::stat_poly_eq(aes(label = ..p.value.label.., group = 1),
                        color = "darkgreen",
                        formula = y ~ x, 
                        method = "lm",
                        label.x = 0.1,
                        label.y = 0.1,  # Position at the top, adjust if necessary
                        parse = TRUE) +
  scale_y_log10() +
  scale_x_log10() +
  xlab("Coefficient of Variation (unitless)") +
  ylab("Organism Mouth Size Opening (um) for Toxicity Datapoint") +
 # xlim(xlims) +  # Set x limits
  color.type +
  theme.light +
  theme(legend.position = "none",
        axis.title.y = element_text(size = 12)) +
  theme(legend.title = element_blank()) +
   guides(fill = guide_legend(title = NULL), color = guide_legend(title = NULL))  # Remove legend titles

CoV_mouth_plots <- ggarrange(mouth_cv_food, mouth_cv_ox,
                       labels = c("Food Dilution", "Tissue Translocation"),
                       ncol = 1,
                       common.legend = TRUE, legend = "bottom")

ggsave(filename = "CoV_mouth_plots.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = CoV_mouth_plots, width = 10, height = 8, units = "in")

CoV_mouth_plots
```


check to see if any CoV are negative (should not be!)
```{r include=FALSE}
aoc_MC %>% 
  filter(CoV_food_dilution < 0)
```
### Fiter data
```{r}
getwd()
source("monte carlo/ssd_functions.R")

freshwater_MC_data <-  filter_environment_data(data = aoc_MC %>% 
                                                 rename(particles.mL.ox.stress = particles.mL.ox.stress.x,
                                                        particles.mL.food.dilution = particles.mL.food.dilution.x) %>% 
                                                 mutate(translocatable = ifelse(size.length.um.used.for.conversions > x2M_trans, 
                                   "not translocatable", 
                                   "translocatable")) %>% 
    mutate(ingestible = ifelse(size.length.um.used.for.conversions > x2M_ingest, 
                               "not ingestible", 
                               "ingestible")),
                                              env_filter =  "Freshwater", 
                                              upper.tissue.trans.size.um = upper.tissue.trans.size.um,
                                              x1D_set = x1D_set, 
                                              x2D_set = x2D_set
                                              )

```

### Example MC Results
```{r}
example.df.freshwater.tissue <-  left_join(results_df,
          freshwater_MC_data$filtered_data_small_default_t3_4 %>% select(c(unique_id,
                                                                           particles_L_food_dilution_deterministic,
                                                                           particles_L_ox_stress_deterministic,
                                                                           CoV_ox_stress, CoV_food_dilution,
                                                                           Species, Group, max.size.ingest.um,
                                                                           size.length.um.used.for.conversions,
                                                                           shape_f,
                                                                           poly_f)),
          by = "unique_id")

example.df.freshwater.food <-  left_join(results_df,
          freshwater_MC_data$filtered_data_large_default_t3_4 %>% select(c(unique_id,
                                                                           particles_L_food_dilution_deterministic,
                                                                           particles_L_ox_stress_deterministic,
                                                                           CoV_ox_stress, CoV_food_dilution,
                                                                           Species, Group, max.size.ingest.um,
                                                                           size.length.um.used.for.conversions,
                                                                           shape_f,
                                                                           poly_f)),
          by = "unique_id")

#get a few rowids to select for plotting
example.unique_id.ox.stress.max <- example.df.freshwater.tissue %>% 
  arrange(desc(CoV_ox_stress)) %>% 
  slice(1) %>% 
  pull(unique_id)
  

example.unique_id.ox.stress.min <- example.df.freshwater.tissue %>% 
  arrange(CoV_ox_stress) %>% 
   slice(1) %>% 
  pull(unique_id)
  
example.unique_id.food.max <- example.df.freshwater.food %>% 
    filter(Group != "Algae") %>% 
  arrange(desc(CoV_food_dilution)) %>% 
  slice(1) %>% 
  pull(unique_id)

example.unique_id.food.min <- example.df.freshwater.food %>% 
    filter(Group != "Algae") %>% 
  arrange(CoV_food_dilution) %>% 
   slice(1) %>% 
  pull(unique_id)
  
# Function to create ggplot for given unique_id and description
create_ggplot_ox_stress <- function(df_input, unique_id_input, plot_type) {

df_example <- df_input %>% filter(unique_id == unique_id_input)
    
example.species = as.character(df_example$Species[1])
example.group = as.character(df_example$Group[1])
example.particle.length = comma(df_example$size.length.um.used.for.conversions[1])
example.CoV = scientific(df_example$CoV_ox_stress,5)
example.max.size.ingest = comma(df_example$max.size.ingest.um[1])

  df_example %>%
    ggplot() +
    geom_histogram(aes(x = particles_L_ox_stress,
                       y = ..density..), fill = "darkorange", color = "orange", alpha = 0.5,
                   bins = 100) +
    scale_x_log10(labels = label_scientific(accuracy = 1)) +
    labs(x = "Tissue Translocation EC (Particles/L)",
         y = "Probability density",
      #   title = "Monte Carlo Distribution of Effect Concentration",
           subtitle = paste0(example.species, " (", example.group, ") \n ",
                           "Mouth size: ",example.max.size.ingest, " um",
                           "\n ",
                           "CoV:", example.CoV,
                           "\n",
                           "Particle length: ",
                           example.particle.length, " um")) +
    geom_vline(aes(xintercept = particles_L_ox_stress_deterministic),
               linewidth = 1.7, linetype = "dotted", color = "red"
               ) +
    #geom_density(aes(x = particles_L_ox_stress),
    #              col = "red", lwd = 1) # Optionally add a density line
    theme_light()
}

create_ggplot_food_dilution <- function(df_input, unique_id_input, plot_type) {

df_example <- df_input %>%  filter(unique_id == unique_id_input)
    
example.species = as.character(df_example$Species[1])
example.group = as.character(df_example$Group[1])
example.particle.length = comma(df_example$size.length.um.used.for.conversions[1])
example.CoV = scientific(df_example$CoV_food_dilution,5)
example.max.size.ingest = comma(df_example$max.size.ingest.um[1])


  df_example %>%
    ggplot(aes(x = particles_L_food_dilution)) +
    geom_histogram(aes(y = ..density..), fill = "#663399", color = "#E6E6FA", alpha = 0.5,
                   bins = 100) +
    scale_x_log10(labels = label_scientific(accuracy = 0.1)) +
    labs(x = "Food Dilution EC (Particles/L)",
         y = "Probability density",
       #  title = "Monte Carlo Distribution of Effect Concentration",
         subtitle = paste0(example.species, " (", example.group, ") \n ",
                           "Mouth size: ",example.max.size.ingest, " um",
                           "\n ",
                           "CoV:", example.CoV,
                           "\n",
                           "Particle length: ",
                           example.particle.length, " um")) +
    geom_vline(aes(xintercept = particles_L_food_dilution_deterministic),
               linewidth = 1.7, linetype = "dotted", color = "#663399"
               ) +
    #$geom_density(col = "#663399", lwd = 1) + # Optionally add a density line
    theme_light()
}

plot_ox_stress_max <- create_ggplot_ox_stress(df_input = example.df.freshwater.tissue,
                                              example.unique_id.ox.stress.max,  "High CoV (Tissue Translocation)")
plot_ox_stress_min <- create_ggplot_ox_stress(df_input = example.df.freshwater.tissue,
                                              example.unique_id.ox.stress.min, "Low CoV (Tissue Translocation)")
plot_food_max <- create_ggplot_food_dilution(df_input = example.df.freshwater.food,
                                             example.unique_id.food.max, "High CoV (Food Dilution)")
plot_food_min <- create_ggplot_food_dilution(df_input = example.df.freshwater.food,
                                             example.unique_id.food.min, "Low CoV (Food Dilution)")


MC_example_plots <- ggarrange(plot_ox_stress_max, plot_ox_stress_min,
                              plot_food_max, plot_food_min,
                              labels = c("A", "B", "C", "D")
                              )

ggsave(filename = "MC_example_plots.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = MC_example_plots, width = 10, height = 8, units = "in")

MC_example_plots
```


#### Filtering for threshold prep
```{r}
#filter out risk criteria (not done above)#
aoc_risk_paper_MC <- aoc_MC %>% 
  drop_na(effect.metric) %>% 
   filter(
     tier_zero_tech_f == ("Red Criteria Passed"))

####---- TISSUE TRANSLOCATION ------#####
filtered.data.small.default_t1.2_MC <- aoc_risk_paper_MC %>% 
          #mutate(dose_new = particles.L.ox.stress / (af.time * af.noec)) %>% #we should determine if the AFs should be applied, bc I think pSSD does this
         mutate(dose_new_particles_L = mean_particles_L_ox_stress) %>% 
         mutate(dose_new_particles_L_sd = sd_particles_L_ox_stress) %>% 
         drop_na(dose_new_particles_L) %>% 
  filter(between(size.length.um.used.for.conversions, 1, upper.tissue.trans.size.um),
         shape_f != "Not Reported",
         poly_f != "Not Reported",
         !environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC")

filtered.data.small.default_t3.4_MC <- filtered.data.small.default_t1.2_MC %>% 
 filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"))

####---- Food Dilution ------#####
filtered.data.large.default_t1.2_MC <- aoc_risk_paper_MC %>% 
   # remove algae, as food dilution MOE doesn't make sense for algae
  filter(Group != "Algae") %>% 
    filter(between(size.length.um.used.for.conversions, x1D_set, x2D_set),
         poly_f != "Not Reported",
         !environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC") %>% 
         #mutate(dose_new = particles.L.food.dilution / (af.time * af.noec)) %>%  #we should determine if the AFs should be applied, bc I think pSSD does this
         mutate(dose_new_particles_L = mean_particles_L_food_dilution) %>% 
         mutate(dose_new_particles_L_sd = sd_particles_L_food_dilution) %>% 
         drop_na(dose_new_particles_L)


filtered.data.large.default_t3.4_MC <- filtered.data.large.default_t1.2_MC %>% 
 filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"))

```



# Probabilistic Species Sensitivity Distribution Plus

```{r eval=TRUE, include=FALSE}
#food dilution
tier1_2_food <- filtered.data.large.default_t1.2_MC
tier3_4_food <- filtered.data.large.default_t3.4_MC

#tissue translocation
tier1_2_tissue <- filtered.data.small.default_t1.2_MC
tier3_4_tissue <- filtered.data.small.default_t3.4_MC

##  save datasets for other scripts and the paper
saveRDS(tier1_2_food, "../data/output/tier1_2_food.RDS")
saveRDS(tier3_4_food, "../data/output/tier3_4_food.RDS")
saveRDS(tier1_2_tissue, "../data/output/tier1_2_tissue.RDS")
saveRDS(tier3_4_tissue, "../data/output/tier3_4_tissue.RDS")
```

## Summarize datasets
```{r}
### count unique studies, datapoints, and species
#function
summarize_distinct <- function(data, name) {
  summary <- data %>%
    summarize(
      Count_Distinct_Species = n_distinct(Species),
      Count_Distinct_doi = n_distinct(doi),
      Count_Distinct_dp = n_distinct(dose_new_particles_L),
      Count_Distinct_group = n_distinct(Group)
    ) %>%
    mutate(Dataset = name)  # Adding a column to identify the dataframe
  return(summary)
}

#application
tier1_2_food_summary <- summarize_distinct(tier1_2_food, "Tier 1-2 Food")
tier3_4_food_summary <- summarize_distinct(tier3_4_food, "Tier 3-4 Food")
tier1_2_tissue_summary <- summarize_distinct(tier1_2_tissue, "Tier 1-2 Tissue")
tier3_4_tissue_summary <- summarize_distinct(tier3_4_tissue, "Tier 3-4 Tissue")

tier1_2_food_summary_OG <- summarize_distinct(tier1_2_food %>% filter(source != "ToMEx 2.0"), "Tier 1-2 Food - ToMEx 1")
tier3_4_food_summary_OG <- summarize_distinct(tier3_4_food %>% filter(source != "ToMEx 2.0"), "Tier 3-4 Food - ToMEx 1")
tier1_2_tissue_summary_OG <- summarize_distinct(tier1_2_tissue %>% filter(source != "ToMEx 2.0"),"Tier 1-2 Tissue - ToMEx 1")
tier3_4_tissue_summary_OG <- summarize_distinct(tier3_4_tissue %>% filter(source != "ToMEx 2.0"), "Tier 3-4 Tissue - ToMEx 1")

#combine into single dataframe
final_summary <- bind_rows(tier1_2_food_summary, tier3_4_food_summary,
                           tier1_2_tissue_summary, tier3_4_tissue_summary,
                           tier1_2_food_summary_OG, tier3_4_food_summary_OG,
                           tier1_2_tissue_summary_OG, tier3_4_tissue_summary_OG,)

#display
print(final_summary)
```


```{r eval=TRUE, include=FALSE}
# -------------------------------------------------------------------------------------------------
# Code based on PSSD and PNEC calculations using the tool PSSD+ developed by Wigger et al. (2019)
# -------------------------------------------------------------------------------------------------
# 
# Associated publication: Systematic consideration of parameter uncertainty and variability in
#                         probabilistic species sensitivity distributions
# 
# Authors: Henning Wigger, Delphine Kawecki, Bernd Nowack and V?ronique Adam
# 
# Institute: Empa, Swiss Federal Laboratories for Materials Science and Technology,
#            Technology and Society Laboratory, Lerchenfeldstrasse 5, 9014 St. Gallen, Switzerland
# 
# submitted to Integrated Environmental Assessment and Management in December 2018
# 
# -------------------------------------------------------------------------------------------------

##### Build fun4ctions ####
getwd()
source("PSSD/rmore.r")
source("PSSD/do.pssd.r")
#source("PSSD/do.pssd.troph.r")
#source("PSSD/do.pssd.ag.r")


###################################################################################################
##### MAIN PARAMETERS FOR THE CALCULATION #########################################################
###################################################################################################

# number of simulations for the triangular distributions of the data points and uncertainty factors
SIM <- 1000 #10 is minimum, 10,000 is recommended

# coefficient of variation for the data point distributions
CV.DP <- 0.3 #this arbitray value should be changed to the matrix corresponding to the actual CV for each datapoint, which is calculated above. 
CV.DP.food <- 0.68297352 #average valuie
CV.DP.ox <- 0.06007163 #avearge value

# coefficient of variation for the uncertainty factor distributions
CV.UF <- 0.5 #unclear how this value was derived... I believe it corresponds to the combined uncertainties of the effect metric uncertainty facotr (e.g., LOEC to NOEC, etc.) and the acute to chronic uncertainty factor... maybe just leave as-is for now?
```

## Functions
### Data Preparation
```{r}
#FUnction to process data
prep_data <- function(data) {
  # Base part of the names used for returned list elements
  names <- c("DP", "DP.SD", "UFt", "UFdd", "doseDescriptor", "polymer", "shape", "environment", "group")
  
  # Data processing steps
  matrices <- list(
    DP = data %>% mutate(id = row_number()) %>%
        mutate(particles_L = dose_new_particles_L) %>% #ERM-specific - converted appropripately upstream
        select(id, Species, particles_L) %>%
        acast(id ~ Species, value.var = "particles_L") %>%
        Matrix(sparse = TRUE),
    DP.SD = data %>% mutate(id = row_number()) %>%
        mutate(particles_L_sd = dose_new_particles_L_sd) %>% 
        select(id, Species, particles_L_sd) %>% #ERM-specific - converted appropripately upstream
        acast(id ~ Species, value.var = "particles_L_sd") %>%
        Matrix(sparse = TRUE),
    UFt = data %>% mutate(id = row_number()) %>%
        select(id, Species, af.time) %>%
        acast(id ~ Species, value.var = "af.time") %>% 
        Matrix(sparse = T),
    UFdd = data %>% mutate(id = row_number()) %>% 
        select(id, Species, af.noec) %>% 
        acast(id ~ Species, value.var = "af.noec") %>% 
        Matrix(sparse = T),
    doseDescriptor <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, effect.metric) %>% 
      acast(id ~ Species, value.var = "effect.metric") %>% 
      Matrix(sparse = T),
    polymer_matrix <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, poly_f) %>% 
      acast(id ~ Species, value.var = "poly_f") %>% 
      Matrix(sparse = T),
    shape__matrix <- data %>% 
      mutate(id = row_number()) %>% 
      select(id, Species, shape_f) %>% 
      acast(id ~ Species, value.var = "shape_f") %>% 
      Matrix(sparse = T),
    env_matrix <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, environment) %>% 
      acast(id ~ Species, value.var = "environment") %>% 
      Matrix(sparse = T),
    group_matrix <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, Group) %>% 
      acast(id ~ Species, value.var = "Group") %>% 
      Matrix(sparse = T)
  )
  
  # Rename the list elements based on constructed names
  names(matrices) <- names
  
  # Return the named list of matrices
  matrices
}

#example usage
#tier1_2_food_matrices <- prep_data(tier1_2_food)
```

### Run PSSD
```{r include=FALSE}
run_pSSD_analysis <- function(data_matrices, num_iterations, sim, cv_dp, cv_uf, data_name) {
  # Initialize an empty list to store the results
  pSSD_list <- vector("list", num_iterations)
  
  # Loop through each iteration
  for (i in 1:num_iterations) {
    pSSD_list[[i]] <- do.pSSD(
      DP = data_matrices[["DP"]],  # Correctly reference matrices with dynamic naming
      DP.SD = data_matrices[["DP.SD"]],
      UFt = data_matrices[["UFt"]],
      UFdd = data_matrices[["UFdd"]],
      SIM = sim,
      CV.DP =  cv_dp,
      CV.UF = cv_uf
    )
  }
  
  # Combine all the results into a single object
  pSSD <- do.call(cbind, pSSD_list)
  
  # Save the combined results
  save(pSSD, file = paste0("PSSD/updated/",data_name,".RData"))
  
  # Calculate corrected endpoints
  corr_endpoints <- data_matrices[["DP"]] / (data_matrices[["UFt"]] * data_matrices[["UFdd"]])

  # Optionally return the corrected endpoints or any other result
  return(list(pSSD = pSSD, corr_endpoints = corr_endpoints))
}

# #example
# tier1_2_food_pssd <- run_pSSD_analysis(
#   data_matrices = tier1_2_food_matrices,
#   num_iterations = 10,
#   sim = SIM,
#   cv_dp = CV.DP,  # Example coefficient of variation for DP
#   cv_uf = CV.UF,  # Example coefficient of variation for UF
#   data_name = "tier1_2_food"
# )
```

###Plotting
#### Preparation Function
```{r}
prepare_plot_data <- function(pSSD, data_matrices, species_data_source) {
  # Ensure that the required matrices are present and correctly formatted
  if (is.null(data_matrices[['DP']]) || is.null(data_matrices[['UFdd']]) || is.null(data_matrices[['UFt']])) {
    stop("Data matrices for DP, UFdd, or UFt are not available or incorrect.")
  }

  # Define interpolation values
  iv <- seq(-5, 10, 0.001)
  ECDF.data <- matrix(NA, 10000, length(iv))
  
  # Compute ECDF for each column in pSSD
  for (i in 1:10000) {
    the.ecdf.f <- ecdf(log(pSSD[, i], base = 10))
    ECDF.data[i, ] <- the.ecdf.f(iv)
  }

  # Preparing dataframe for ggplot
  iv_vec <- seq(-5, 10, length.out = ncol(ECDF.data))
  ecdf_df <- data.frame(iv = rep(iv_vec, times = nrow(ECDF.data)), 
                        ecdf_value = as.vector(t(ECDF.data)))

  # Calculating quantiles for shading
  quantiles_df <- ecdf_df %>%
    group_by(iv) %>%
    summarise(min = min(ecdf_value, na.rm = TRUE),
              max = max(ecdf_value, na.rm = TRUE),
              q05 = quantile(ecdf_value, 0.05, na.rm = TRUE),
              q95 = quantile(ecdf_value, 0.95, na.rm = TRUE),
              q25 = quantile(ecdf_value, 0.25, na.rm = TRUE),
              q75 = quantile(ecdf_value, 0.75, na.rm = TRUE),
              mean = mean(ecdf_value, na.rm = TRUE)) %>%
    ungroup()

  # Calculate deterministic values of NOEC
  NOEC.det <- data_matrices[['DP']] / (data_matrices[['UFdd']] * data_matrices[['UFt']])
  
  # Calculate the geometric mean of NOEC
  if (ncol(NOEC.det) > 0 && nrow(NOEC.det) > 0) {
    NOEC.gmean <- apply(NOEC.det, 2, function(x) exp(mean(log(x), na.rm = TRUE)))
  } else {
    stop("NOEC.det matrix is empty or not properly formatted.")
  }
  
  # Creating a dataframe for ggplot with species data
  species_data <- data.frame(
    Species = colnames(NOEC.det),
    NOEC_log10 = log10(NOEC.gmean),
    NOEC = NOEC.gmean,
    Prop = rank(NOEC.gmean) / (length(NOEC.gmean) + 1)
  )

  # Join metadata to species data
  species_data <- species_data %>% 
    left_join(species_data_source %>% distinct(Group, Species), by = "Species") %>% 
    left_join(species_data_source %>% distinct(Species, environment), by = "Species")

  list(quantiles_df = quantiles_df, species_data = species_data)
}

# Example usage
# tier1_2_food_plot_prep <- prepare_plot_data(pSSD = tier1_2_food_pssd$pSSD, 
#                                data_matrices = tier1_2_food_matrices, 
#                                species_data_source = tier1_2_food)

```


#### PSSD ggplot Function
```{r}

pSSD_plot <-  function(quantiles_df = quantiles_df, species_data = species_data, data_name = data_name){
ggplot() +
  geom_ribbon(data = quantiles_df, aes(x = iv, ymin = min, ymax = max), fill = "coral", alpha = 0.1) +
  geom_ribbon(data = quantiles_df, aes(x = iv, ymin = q05, ymax = q95), fill = "coral", alpha = 0.3) +
  geom_ribbon(data = quantiles_df, aes(x = iv, ymin = q25, ymax = q75), fill = "coral", alpha = 0.8) +
  geom_point(data = species_data, aes(x = NOEC_log10, y = Prop, color = Group)) +
  geom_text(data = species_data, aes(x = NOEC_log10, y = Prop, label = Species, color = Group), 
            hjust = -0.2, vjust = 0,
            fontface = "italic",
            family = "helvetica"
            ) +
  geom_line(data = quantiles_df, aes(x = iv, y = mean), color = "firebrick4", size = 1) +
  scale_x_continuous(name = "NOEC (particles/L)", breaks = c(-1, 0, 2, 4, 6, 8,10, 12),
                     labels = expression(10^-1, 1, 10^2, 10^4, 10^6, 10^8, 10^10, 10^12),
                     limits = c(-1, 12)) +
  scale_y_continuous(name = "Cumulative probability", limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  fill.type +
    color.type +
  labs(title = ("Microplastics Probabilistic Species Sensitivity Distribution"),
       subtitle = data_name)
 }

# example usage
# pSSD_plot(quantiles_df = tier1_2_food_plot_prep$quantiles_df,
#           species_data = tier1_2_food_plot_prep$species_data,
#           data_name = "Tier 2 (Food Dilution)")

```

#### PNEC ggplot Function
```{r}
# Calculate PNEC1 if not already calculated
PNEC_plot <- function(pssd_results, hcx, data_name){
  PNEC <- apply(pssd_results$pSSD, 2, function(x) quantile(x, probs = hcx, type = 1))
  # Convert PNEC1 to a dataframe for ggplot
  PNEC_df <- data.frame(PNEC = PNEC)
  
  # Plotting
  ggplot(PNEC_df, aes(x = PNEC)) +
    geom_histogram(aes(y = ..density..), fill = rgb(255, 127, 80, max = 255, alpha = 50), color = "coral",
                   bins = 100)   +
    labs(x = "PNEC (Particles/L)", y = "Probability density", title = "Probability density of the PNEC",
         subtitle = data_name) +
    #theme_minimal() +
    geom_density(col = "red", lwd = 1)  # Optionally add a density line
}

#example
# PNEC_plot(pssd_results = tier1_2_food_pssd,
#            hcx = 0.05
#           data_name = "Tier 2 (Food Dilution)")
```
#### PNEC Data Summary
```{r}
  # Mode calculation using density
Mode_Y <- function(x) {
  dens <- density(x)
  ind <- which(dens$y == max(dens$y))
  return(dens$x[ind])
}

#PNEC Data summary function
PNEC_data_summary <- function(pssd_results, hcx, data_name){

PNEC <- apply(pssd_results$pSSD, 2, function(x) quantile(x, probs = hcx, type = 1))
PNEC_df <- data.frame(PNEC = PNEC)
  
# Calculate statistics for PNEC1
Stat_PNEC <- data.frame(
  Min = min(PNEC),
  Q5 = quantile(PNEC, 0.05),
  Q25 = quantile(PNEC, 0.25),
  Mean = mean(PNEC),
  Median = median(PNEC),
  Mode = Mode_Y(PNEC),
  Q75 = quantile(PNEC, 0.75),
  Q95 = quantile(PNEC, 0.95),
  Max = max(PNEC)
)

# Transposing for similar structure to your matrix
Stat_PNEC_t <- t(Stat_PNEC)
colnames(Stat_PNEC_t) <- paste0(data_name, " - HC", hcx*100)

return(list("stats" = as.data.frame(Stat_PNEC_t),
            "df" = PNEC_df))
}


## example
# tier1_2_food_PNEC <- PNEC_data_summary(pssd_results = tier1_2_food_pssd,
#                                        hcx = 0.05,
#                                        data_name = "Tier 2 (Food Dilution)")
# 
# tier1_2_food_PNEC$df
# tier1_2_food_PNEC$stats
```

## Application
### Tier 1_food
```{r include=FALSE}
#Step 1: prep data matrices
tier1_2_food_matrices <- prep_data(tier1_2_food)

#Step 2: run pSSD
tier1_2_food_pssd <- run_pSSD_analysis(
  data_matrices = tier1_2_food_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP.food,  # Default coefficeint
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier1_2_food"
)

#Step 3: prep for ggplot
tier1_2_food_plot_prep <- prepare_plot_data(pSSD = tier1_2_food_pssd$pSSD,
                                            data_matrices = tier1_2_food_matrices,
                                            species_data_source = tier1_2_food)

#Step 4a: generate ggplot (pSSD)
tier1_2_food_pssdPlot <-  pSSD_plot(quantiles_df = tier1_2_food_plot_prep$quantiles_df,
                                    species_data = tier1_2_food_plot_prep$species_data,
                                    data_name = "Tier 2 (Food Dilution)")

#Step 4b: generate ggplot (PNEC)
tier1_2_food_PNECPlot <-  PNEC_plot(pssd_results = tier1_2_food_pssd,
                                    hcx = 0.05,
                                    data_name = "Tier 2 (Food Dilution)")

# Step 5: extract PNEC values for table
tier1_2_food_PNEC_summary <- PNEC_data_summary(pssd_results = tier1_2_food_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 2 (Food Dilution)")
```

```{r}
ggarrange(tier1_2_food_pssdPlot,tier1_2_food_PNECPlot,
          ncol = 1)


```
```{r}
tier1_2_food_PNEC_summary$stats
```

### Tiers 3 and 4_food
```{r include=FALSE}
#Step 1: prep data matrices
tier3_4_food_matrices <- prep_data(tier3_4_food)

#Step 2: run pSSD
tier3_4_food_pssd <- run_pSSD_analysis(
  data_matrices = tier3_4_food_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP.food,  # Example coefficient of variation for DP
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier3_4_food"
)

#Step 3: prep for ggplot
tier3_4_food_plot_prep <- prepare_plot_data(pSSD = tier3_4_food_pssd$pSSD,
                                            data_matrices = tier3_4_food_matrices,
                                            species_data_source = tier3_4_food)

#Step 4a: generate ggplot (pSSD)
tier3_4_food_pssdPlot <-  pSSD_plot(quantiles_df = tier3_4_food_plot_prep$quantiles_df,
                                    species_data = tier3_4_food_plot_prep$species_data,
                                    data_name = "Tier 3 (Food Dilution)")

#Step 4b: generate ggplot (PNEC)
tier3_food_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_pssd,
                                    hcx = 0.05,
                                    data_name = "Tier 3 (Food Dilution)")

tier4_food_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_pssd,
                                    hcx = 0.10,
                                    data_name = "Tier 4 (Food Dilution)")

# Step 5: extract PNEC values for table
tier3_food_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 3 (Food Dilution)")

tier4_food_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_pssd,
                                               hcx = 0.10,
                                               data_name = "Tier 4 (Food Dilution)")
```

```{r}
food_plots_light <- ggarrange(tier3_4_food_pssdPlot + theme.light + theme(legend.position = c(0.1, 0.6)),  
                        ggarrange(tier3_food_PNECPlot + theme.light,
                                  tier4_food_PNECPlot + theme.light,
                                  ncol = 2, nrow = 1, labels = c("B", "C")),
                        ncol = 1, nrow = 2, labels = c("A"))

ggsave(filename = "food_plots_light.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = food_plots_light, width = 10, height = 8, units = "in")

food_plots_light
```
```{r}
food_plots_dark <- ggarrange(tier3_4_food_pssdPlot + theme.dark + theme(legend.position = c(0.1, 0.6)),  
                        ggarrange(tier3_food_PNECPlot + theme.dark,
                                  tier4_food_PNECPlot + theme.dark,
                                  ncol = 2, nrow = 1, labels = c("B", "C")),
                        ncol = 1, nrow = 2, labels = c("A"))

ggsave(filename = "food_plots_dark.jpg",
       dpi = 300,
       path = "../output/presentation_Figs/", 
       plot = food_plots_dark, width = 10, height = 8, units = "in")

food_plots_dark
```

```{r}
cbind(tier3_food_PNEC_summary$stats, tier4_food_PNEC_summary$stats)
```

### Tier 3 and 4_tissue
```{r include=FALSE}
#Step 1: prep data matrices
tier3_4_tissue_matrices <- prep_data(tier3_4_tissue)

#Step 2: run pSSD
tier3_4_tissue_pssd <- run_pSSD_analysis(
  data_matrices = tier3_4_tissue_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP.ox,  # Example coefficient of variation for DP
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier3_4_tissue"
)

#Step 3: prep for ggplot
tier3_4_tissue_plot_prep <- prepare_plot_data(pSSD = tier3_4_tissue_pssd$pSSD,
                                            data_matrices = tier3_4_tissue_matrices,
                                            species_data_source = tier3_4_tissue)

#Step 4a: generate ggplot (pSSD)
tier3_4_tissue_pssdPlot <-  pSSD_plot(quantiles_df = tier3_4_tissue_plot_prep$quantiles_df,
                                    species_data = tier3_4_tissue_plot_prep$species_data,
                                    data_name = "Tier 3 (Tissue Translocation)") +
    scale_x_continuous(name = "NOEC (particles/L)", breaks = c(0, 2, 4, 6, 8,10),
                     labels = expression(1, 10^2, 10^4, 10^6, 10^8, 10^10),
                     limits = c(0, 10))

#Step 4b: generate ggplot (PNEC)
tier3_tissue_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_tissue_pssd,
                                      hcx = 0.05,
                                      data_name = "Tier 3 (Tissue Translocation)")

tier4_tissue_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_tissue_pssd,
                                      hcx = 0.10,
                                      data_name = "Tier 3 (Tissue Translocation)")

# Step 5: extract PNEC values for table
tier3_tissue_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_tissue_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 3 (Tissue Translocation)")

tier4_tissue_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_tissue_pssd,
                                               hcx = 0.10,
                                               data_name = "Tier 4 (Tissue Translocation)")
```

```{r}
tissue_plots_light <- ggarrange(tier3_4_tissue_pssdPlot + theme.light + theme(legend.position = c(0.15, 0.6)),  
                        ggarrange(tier3_tissue_PNECPlot + theme.light,
                                  tier4_tissue_PNECPlot + theme.light,
                                  ncol = 2, nrow = 1, labels = c("B", "C")),
                        ncol = 1, nrow = 2, labels = c("A"))

ggsave(filename = "tissue_plots_light.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = tissue_plots_light, width = 10, height = 8, units = "in")

tissue_plots_light
```
```{r}
tissue_plots_dark <- ggarrange(tier3_4_tissue_pssdPlot + theme.dark + theme(legend.position = c(0.15, 0.6)),  
                        ggarrange(tier3_tissue_PNECPlot + theme.dark,
                                  tier4_tissue_PNECPlot + theme.dark,
                                  ncol = 2, nrow = 1, labels = c("B", "C")),
                        ncol = 1, nrow = 2, labels = c("A"))

ggsave(filename = "tissue_plots_dark.jpg",
       dpi = 300,
       path = "../output/Manuscript_Figs/", 
       plot = tissue_plots_dark, width = 10, height = 8, units = "in")

tissue_plots_dark
```

```{r}
cbind(tier3_tissue_PNEC_summary$stats, tier4_tissue_PNEC_summary$stats)
```

## Summary
### Table
```{r}
summary_table <- cbind(tier3_food_PNEC_summary$stats, tier4_food_PNEC_summary$stats,
                       tier3_tissue_PNEC_summary$stats, tier4_tissue_PNEC_summary$stats) %>% 
  mutate(across(where(is.numeric), round, digits = 3))

summary_table
```
```{r}
base_tissue <- data.frame(Tier = c("1", "2", "3", "4"),
                          ERM = "Tissue Translocation", 
                          PNEC = base_thresholds$`Tissue Translocation (Default)`,
                          PNEClcl = base_thresholds$`Tissue Translocation (5th %)`,
                          PNECucl = base_thresholds$`Tissue Translocation (95th %)`)

base_food <- data.frame(Tier = c("1", "2", "3", "4"),
                        ERM = "Food Dilution", 
                        PNEC = base_thresholds$`Food Dilution (Default)`,
                        PNEClcl = base_thresholds$`Food Dilution (5th %)`,
                        PNECucl = base_thresholds$`Food Dilution (95th %)`)

base_thesholds_df <- rbind(base_tissue, base_food) %>% 
   mutate(y_position = (as.numeric(Tier) - 2) + (as.numeric(factor(ERM)) - 1.5) * 0.9)  # Adjust 0.1 or other value as needed

base_thesholds_df
```


### Plot Comparisons with Deterministic Approach
```{r}
#data prep
t3f <- data.frame(ERM = "Food Dilution", Tier = "3",PNEC = tier3_food_PNEC_summary$df)
t4f <- data.frame(ERM = "Food Dilution", Tier = "4",PNEC = tier4_food_PNEC_summary$df)
t3t <- data.frame(ERM = "Tissue Translocation", Tier = "3",PNEC = tier3_tissue_PNEC_summary$df)
t4t <- data.frame(ERM = "Tissue Translocation", Tier = "4",PNEC = tier4_tissue_PNEC_summary$df)

## join DFs
PNEC_dfs <- rbind(t3f, t4f, t3t, t4t) %>% 
  mutate(y_position = (as.numeric(Tier) - 2) + (as.numeric(factor(ERM)) - 1.5) * 0.4)  # Adjust 0.1 or other value as needed

#plot
PNEC_pSSDvSSD <- ggplot() +
   geom_violin(data = PNEC_dfs, aes(x = PNEC, y = Tier, fill = ERM, color = ERM),
               draw_quantiles = c(0.05, 0.5, 0.95), color = "white", linewidth = 1.2,
               alpha = 0.75) +
   geom_jitter(data = PNEC_dfs, aes(x = PNEC, y = y_position, fill = ERM, color = ERM),
               height = 0.15, size = 1.5, alpha = 0.03) +  # Jittered points
   geom_point(data = base_thesholds_df %>% filter(Tier>2), 
              aes(x = PNEC, y = y_position, fill = ERM),
              size = 5, shape = 23, 
              color = "white",
              alpha = 0.95,
              stroke = 1.8 #thickness of outline
              ) +
   geom_errorbarh(data = base_thesholds_df %>% filter(Tier>2), 
                  aes(xmin = PNEClcl, xmax = PNECucl, y = y_position, fill = ERM, color = ERM),
                  height = 0.2,
                  alpha = 0.75,
                  linewidth = 1.2) +
   scale_x_log10(breaks = c(0.01, 0.1, 1, 10, 100, 1000, 10000, 1000000, 10000000),
                 #limits = c(0.001, 10000000),
                 labels = scales::label_comma()) +
  labs(title = "Comparison of pSSD and SSD Tier Thresholds",
       subtitle = "(Violin Plots/Points = pSSD; Diamonds/Error-Bars = SSD)",
       fill = "Ecologically-Relevant Metric",
       color = "Ecologically-Relevant Metric"
       ) +
  xlab("PNEC (Particles/L; 1 to 5,000 um)") +
  ylab("Threshold Tier")

PNEC_pSSDvSSD_dark <- PNEC_pSSDvSSD + theme.dark
PNEC_pSSDvSSD_light <- PNEC_pSSDvSSD + theme.light

# ggsave(filename = "PNEC_pSSDvSSD.tiff",
#        path = "../output/presentation_Figs/", 
#        plot = PNEC_pSSDvSSD_dark, width = 12, height = 10, units = "in")

ggsave(filename = "PNEC_pSSDvSSD.jpg",
       path = "../output/presentation_Figs/", 
       plot = PNEC_pSSDvSSD_dark, width = 12, height = 10, units = "in")

ggsave(filename = "PNEC_pSSDvSSD.tiff",
       path = "../output/Manuscript_Figs/", 
       plot = PNEC_pSSDvSSD_light, width = 10, height = 8, units = "in")

ggsave(filename = "PNEC_pSSDvSSD.jpg",
       path = "../output/Manuscript_Figs/", 
       plot = PNEC_pSSDvSSD_light, width = 10, height = 8, units = "in")

PNEC_pSSDvSSD_dark
```
## Supplemental
### Freshwater Only
#### Data Filtering
```{r}
#food dilution
tier1_2_food_freshwater <- tier1_2_food %>% filter(environment == "Freshwater")
tier3_4_food_freshwater <- tier3_4_food %>% filter(environment == "Freshwater")

#tissue translocation
tier1_2_tissue_freshwater <- tier1_2_tissue %>% filter(environment == "Freshwater")
tier3_4_tissue_freshwater <- tier3_4_tissue %>% filter(environment == "Freshwater")
```
#### Processing
```{r include=FALSE}
### Food Dilution
#Step 1: prep data matrices
tier3_4_food_freshwater_matrices <- prep_data(tier3_4_food_freshwater)

#Step 2: run pSSD
tier3_4_food_freshwater_pssd <- run_pSSD_analysis(data_matrices = tier3_4_food_freshwater_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP.food,  # Example coefficient of variation for DP
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier3_4_food_freshwater")

#Step 3: prep for ggplot
tier3_4_food_freshwater_plot_prep <- prepare_plot_data(pSSD = tier3_4_food_freshwater_pssd$pSSD,
                                            data_matrices = tier3_4_food_freshwater_matrices,
                                            species_data_source = tier3_4_food_freshwater)

#Step 4a: generate ggplot (pSSD)
tier3_4_food_freshwater_pssdPlot <-  pSSD_plot(quantiles_df = tier3_4_food_freshwater_plot_prep$quantiles_df,
                                    species_data = tier3_4_food_freshwater_plot_prep$species_data,
                                    data_name = "Tier 3 (Food Dilution - Freshwater Only)")

#Step 4b: generate ggplot (PNEC)
tier3_food_freshwater_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_freshwater_pssd,
                                             hcx = 0.05,
                                             data_name = "Tier 3 (Food Dilution - Freshwater Only)")

tier4_food_freshwater_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_freshwater_pssd,
                                             hcx = 0.10,
                                             data_name = "Tier 4 (Food Dilution - Freshwater Only)")

# Step 5: extract PNEC values for table
tier3_food_freshwater_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_freshwater_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 3 (Food Dilution - Freshwater Only)")

tier4_food_freshwater_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_freshwater_pssd,
                                               hcx = 0.10,
                                               data_name = "Tier 4 (Food Dilution - Freshwater Only)")

freshwater_food_plots <- ggarrange(tier3_4_food_freshwater_pssdPlot,  
                        ggarrange(tier3_food_freshwater_PNECPlot,
                                  tier4_food_freshwater_PNECPlot,
                                  ncol = 2, nrow = 1),
                        ncol = 1, nrow = 2)

freshwater_food_plots
```

