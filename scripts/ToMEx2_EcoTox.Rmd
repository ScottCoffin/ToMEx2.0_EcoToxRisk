---
title: "EcoTox - ToMEx 2"
author: "Scott Coffin"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: journal
    toc: yes
    toc_float: yes
    toc_depth: 6
    number_sections: true
  word_document:
    toc: yes
---
#Setup

```{r, setup, include=FALSE}
#knitr::opts_knit$set(root.dir = "G:/My Drive/MooreInstitute/Projects/ToMEx2.0_EcoToxRisk")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=8, fig.path='output/figures',
                      warning=FALSE, message=FALSE,time_it = TRUE) 
```

## Libraries
```{r Libraries, include = FALSE}
library(tidyverse)
library(calecopal)
library(ssdtools)
library(DT)
library(plotly)
library(gridExtra)
library(grid)
library(wesanderson)
library(ggdark)
library(broom)
library(knitr)
library(kableExtra)
library(viridis)
library(ggrepel)
library(scales)
library(gt)
library(ggsci)
library(openxlsx)
library(ggpubr)
library(psych) # To use the geometric.mean function
library(Matrix)
library(mc2d)
library(trapezoid)
library(reshape2)
getwd()

```

```{r Set Particle Size, include = FALSE}
###define sizes for filtering and alignment##
# smaller size bin
small_tier_lower_size <- 1 #um
small_tier_upper_size <- 5000 #um #size to align to
upper.tissue.trans.size.um <- 83 #um #set size for filtering data and x2M
# larger size bin
large_tier_lower_size <- 1 #um
large_tier_upper_size <- 5000 #um
```

```{r Aesthetics, include = FALSE}
#Theme
theme.type <- dark_theme_bw(base_size = 15) +
  #theme_bw(base_size = 15) +
              theme(plot.title = element_text(hjust = 0.5),
                    plot.subtitle = element_text(hjust = 0.5))

#Fill
fill.type <-  scale_fill_nejm()

#Color
color.type <- scale_color_nejm()
```

### Data Import
```{r Data Import, include = FALSE}
#Load aoc_z into dataframe. This file is generated from aq_mp_tox_shiny repo / ToMEx2.0_Onboarding / ToMEx2.0_Data_Tidying.R

#aoc_z <- readRDS(file = "G:/My Drive/MooreInstitute/Projects/ToMEx2.0_EcoToxRisk/data/input/aoc_z_tomex2.RDS") %>% 
  #rename columns so they fir the OG script
getwd()

aoc_z <- readRDS("../data/input/aoc_z_tomex2.RDS") %>% 
  rename(environment = env_f) %>% 
  select(-rowid)# %>% #existing rowid is actually replicated (not sure how)
  #mutate(rowid = row_number())

aoc_z$rowid <- sapply(seq_len(nrow(aoc_z)), function(x) uuid::UUIDgenerate())
```

### Data Cleanup
A large number of values is getting filtered out during alignments. This should not be the case. We can debug by looking at missing values for the parameters that are relevant to alignments.
```{r}
aoc_simple <- aoc_z %>%
   filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
         exp_type_f == "Particle Only",
         tier_zero_tech_f == "Red Criteria Passed",
         tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) %>% 
  ungroup()# %>% 
  #select(c(rowid, max.size.ingest.mm, dose.particles.mL.master, particle.surface.area.um2,
         #  particle.surface.area.um2.min, particle.surface.area.um2.max, polydispersity)) 

# for polydisperse data, we need the particle.surface.area.um2.min and max to be filled out. For monodisperse data, just the particle.surface.area.um2 is needed.

aoc_simple_check <- aoc_simple %>% 
   mutate(data_available = case_when(
    # Condition for polydisperse: particle.surface.area.um2.min and .max cannot be NA
    polydispersity == "polydisperse" & !is.na(particle.surface.area.um2.min) & !is.na(particle.surface.area.um2.max) ~ TRUE,
    # Condition for monodisperse: particle.surface.area.um2 cannot be NA
    polydispersity == "monodisperse" & !is.na(particle.surface.area.um2) ~ TRUE,
    # Otherwise, data is not available according to the criteria
    TRUE ~ FALSE
  )) %>% 
  drop_na(dose.particles.mL.master)

aoc_simple_check %>% 
  filter(!data_available)
```


#Framework Summary

![Agreed-upon framework](../assets/threshold_framework.png)

The figure above displays the working threshold framework for the ambient threshold group for the Microplastics Health Effects Workshop. 

The current framework for generating SSDs includes the following parameters:

Data pertaining to only aquatic organisms are included (marine and freshwater).  

All taxa are included with the exception of bacterium and plants.  

HONEC (Highest Observed No Effect Concentration) are excluded.  

Assessment factors are applied to convert all other effect metrics into NOECs:

![](../assets/AF_EM.png)

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)  

Assessment factors are applied to convert acute data into chronic:  

![](../assets/AF_chronic.png)

Green rows are from Wigger et al. 2020. Grey rows were agreed upon by the ambient threshold working group.

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)

Note: Values may be slightly different than those presented in the shiny app as concentrations are converted from particles/mL to particles/L ahead of calculations.


# ERM/SSD Calculations
The following script utilizes the above equations to calculate *a priori* effect thresholds for each of the ERM of interest for each species in the database, then calculates species sensitivity distributions using each ERM.

*Data Filtering by Quality*
```{r}
## First filter data with global filters
aoc_intermediate <- aoc_z %>% 
  filter(!environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC",
         tier_zero_tech_f == "Red Criteria Passed",
         tier_zero_risk_f == "Red Criteria Passed", #All thresholds must pass technical and risk red criteria
         risk.13 != 0 #Drop studies that received a score of 0 for endpoints criteria (this also drops studies that have not yet been scored) - KEEP THIS AFTER THE RED CRITERIA FILTERS  
         ) %>% 
  #Remove 26C temperature treatment data from Jaimukar et al. 2018
  filter(!(article == 42 & media.temp == 26)) %>% 
  mutate(max.size.ingest.um = 1000 * max.size.ingest.mm) #makes it less confusing below

### NEED TO DETERMINE FILTERING PROTOCOL FOR CASES IN WHICH SPECIES HAVE MANY LOECS OR NOECS FOR SAME DOSE FOR SLIGHTLY SIMILIAR ENDPOINTS - E.G., MYTILUS GALLOPROVENCIALIS ###


#### Ecologically Relevant Metric calculations ####

#examine available data as histogram
Group_size <- aoc_intermediate %>% 
  ggplot(aes(x = size.length.um.used.for.conversions, fill = Group)) +
  geom_histogram(bins = 25) +
  scale_fill_manual(values = cal_palette(name = "superbloom1", type = "continuous", n = 11)) +
  labs(title = "Filtered Data by Group") +
  ylab("# of observations")+
  xlab("Length (um)") +
  theme.type +
  scale_x_log10()

endpoint_size <- aoc_intermediate %>% 
  ggplot(aes(x = size.length.um.used.for.conversions, fill = lvl1_f)) +
  geom_histogram(bins = 25) +
   scale_fill_manual(name = "General Endpoint", values = cal_palette(name = "superbloom3", type = "continuous", n = 11)) +
  xlab("Particle Length (um)") +
  ylab("# of observations")+
  labs(title = "Filtered Data by General Endpoint") +
  theme.type +
  scale_x_log10()

#arrange histograms
grid.arrange(Group_size, endpoint_size)
```

### Alignment

#### Parameters
```{r}
## parametrization ##
# Define params for correction #
alpha = 2.07 #table s4 for marine surface water. length
# define parameters for power law coefficients
a.sa = 1.5 #marine surface area power law
a.v = 1.48 #a_V for marine surface water volume
a.m = 1.32 # upper limit fora_m for mass for marine surface water in table S4 
a.ssa = 1.98 # A_SSA for marine surface water

#define additional parameters for calculations based on averages in the environment
R.ave = 0.77 #average width to length ratio for microplastics in marine enviornment
p.ave = 1.10 #average density in marine surface water

#join alpha values for each data point
aoc_intermediate_alphas <- aoc_intermediate %>% 
  mutate(alpha = alpha) %>% 
  mutate(a.sa = a.sa) %>% 
   mutate(a.v =  a.v) %>% 
   mutate(a.m =  a.m) %>% 
   mutate(a.ssa = a.ssa) %>% 
   mutate(R.ave = R.ave) %>% 
   mutate(p.ave = p.ave)
```

#### Functions
```{r}
###function to derive correction factor (CF) from Koelmans et al (equation 2)
CFfnx = function(a, #default alpha from Koelmans et al (2020)
                 x2D, #set detault values to convert ranges to (1-5,000 um) #5mm is upper defuault 
                 x1D, #1 um is lower default size
                 x2M, x1M){
  CF = (x2D^(1-a)-x1D^(1-a))/(x2M^(1-a)-x1M^(1-a)) 
  return(CF)}

#### equations for mu_x_poly (note that there are three depending on certain alphas for limits of equation)
#generalizable if a.x =2 or not
mux.polyfnx_generalizable = Vectorize(function(a.x, x_UL, x_LL){
  if(a.x == 1){ # in case a.x = 1
    mux.poly = (x_UL - x_LL)/(log(x_UL/x_LL))
    return(mux.poly)}
  if(a.x == 2){ # in case a.x = 2
     mux.poly = (log10(x_UL/x_LL))/(x_LL^(-1) - x_UL^-1)
     return(mux.poly)}
  else{ #in case alpha is not 2 or 1
    mux.poly = ((1-a.x)/(2-a.x)) * ((x_UL^(2-a.x) - x_LL^(2-a.x))/(x_UL^(1-a.x) - x_LL^(1-a.x)))
    return(mux.poly)}
  },
  vectorize.args = "a.x") # if Vectorize isn't here, the if else won't work
## ^^ Note that the above generalizable function doesn't play well with mutate(case_when), likely due to some bug with dplyr. I don't have a solution to this, so a special equation will need to be used when those values are used...

#in case alpha is not 1 or 2
mux.polyfnx = function(a.x, x_UL, x_LL){
    mux.poly = ((1-a.x)/(2-a.x)) * ((x_UL^(2-a.x) - x_LL^(2-a.x))/(x_UL^(1-a.x) - x_LL^(1-a.x)))
    return(mux.poly)}

##### If alpha does equal 2 #####
mux.polyfnx2 = function(a.x, x_UL,x_LL){
  mux.poly = (log(x_UL/x_LL))/(x_LL^(-1) - x_UL^-1)
  return(mux.poly)}

##### If alpha equals 1 #####
mux.polyfnx1 = function(a.x, x_UL, x_LL){
     mux.poly = (x_UL - x_LL)/(log(x_UL/x_LL)) #natural log
    return(mux.poly)}

### Calculating max ingestible parameters ###
## function to calcualte min and max ingestible surface area ##
SAfnx = function(a, # a = 0.5 * length
                 b, # b = 0.5 * width
                 c # c = 0.5 * height (note that hieght is 0.67 * width)
){
  SA = 4*pi*(((a*b)^1.6 + (a*c)^1.6 + (b*c)^1.6) / 3)^(1/1.6)
  return(SA)}

## max ingestible volume ##

volumefnx = function(R, L){
  volume = 0.111667 * pi * R^2 * L^3 #assumes height = 0.67 * Width, and Width:Length ratio is 'R' (compartment-specific)
  return(volume)}

volumefnx_poly = function(width, length){
  height = 0.67 * width
  volume = (4/3) * pi * (length/2) * (width/2) * (height/2) #assumes height = 0.67 * Width 
  return(volume)}

#max ingestible mass (only used for mu_mono calculations)
massfnx = function(R, L, p){
  mass = p * #density (g/cm^3)
    0.111667 * pi * R^2 * L^3 * # volume (um^3): assumes height = 0.67 * Width, and Width:Length ratio is 'R' (compartment-specific)
    1/1e12 * 1e6 #correction factor
  return(mass)}

massfnx_poly = function(width, length, p){
  height = 0.67 * width
  volume = (4/3) * pi * (length/2) * (width/2) * (height/2) #assumes height = 0.67 * Width 
  mass = p * #density (g/cm^3)
    volume * # volume (um^3): assumes height = 0.67 * Width, and Width:Length ratio is 'R' (compartment-specific)
    1/1e12 * 1e6 #correction factor
  return(mass)}

#max ingestible specific surface area
SSAfnx = function(sa, #surface area, calcaulted elsewhere
                  m){ #mass, calculated elsewhere
  SSA = sa/m
    return(SSA)}

#max ingestible specific surface area
SSA.inversefnx = function(sa, #surface area, calcaulted elsewhere
                  m){ #mass, calculated elsewhere
  SSA.inverse = m / sa
    return(SSA.inverse)}
```

#### Calculate

Here we will calculate two aligned exposure concentrations: surface area (1 - 83 um), and volume (1 - 5,000 um). For both, the upper aligned value is the smaller of either the nominal size listed or the mouth size of the species.

```{r}
###define sizes for alignment##
x1M_set <- 1 #um lower size for all alignments
x1D_set <- 1 #um lower size for all alignments
x2D_set <- 5000 #um
upper.tissue.trans.size.um <- 83 #10 #um #set size for x2M

# calculate ERM for each species
aoc_final <- aoc_intermediate_alphas  %>% 
   #### TISSUE TRANSLOCATION ####
# define upper size length for Translocation 
#set to 83um for upper limit or max size ingest, whichever is smaller
mutate(x2M_trans = case_when(is.na(max.size.ingest.um) ~ upper.tissue.trans.size.um, 
                             max.size.ingest.um  < upper.tissue.trans.size.um ~  max.size.ingest.um,
                             max.size.ingest.um  > upper.tissue.trans.size.um ~ upper.tissue.trans.size.um)) %>% 
  
 # calculate effect threshold for particles
  mutate(EC_mono_p.particles.mL_trans = dose.particles.mL.master) %>% 
  mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
  mutate(mu.p.poly_trans = mux.polyfnx(a.x = alpha, #alpha for particles
                                 x_UL= x2M_trans, #upper ingestible size limit (width of particle)
                                 x_LL = x1M_set)) %>% 
  # polydisperse effect threshold for particles
  mutate(EC_poly_p.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.p.mono)/mu.p.poly_trans) %>% 
   #calculate CF_bio for all conversions
  mutate(CF_bio_trans = CFfnx(x1M = x1M_set,#lower size bin
                        x2M = x2M_trans, #upper translocatable
                        x1D = x1D_set, #default
                        x2D = x2D_set,  #default
                        a = alpha)) %>%  
  ## Calculate environmentally relevant effect threshold for particles
  mutate(EC_env_p.particles.mL_trans = EC_poly_p.particles.mL_trans * CF_bio_trans) %>%  #aligned particle effect concentraiton (1-5000 um)
  
  #### Surface area ERM ####
##--- environmental calculations ---###
  #calculate lower translocatable surface area
  mutate(x_LL_sa_trans = SAfnx(a = 0.5 * x1D_set, #length
                               b = 0.5 * x1D_set, #0.5 * R.ave * x1D_set, #width
                               c = 0.5 * x1D_set  #0.5 * R.ave * 0.67 * x1D_set #height
                               )) %>%  
  #calculate upper translocatable surface area
  mutate(x_UL_sa_trans = SAfnx(a = 0.5 * x2M_trans, 
                               b = 0.5 * x2M_trans, #width #0.5 * R.ave * x2M, 
                               c = 0.5 * x2M_trans #heigth #0.5 * R.ave * 0.67 * x2M
                               )) %>%  
  #calculate mu_x_poly (env) for surface area
  mutate(mu.sa.poly_trans = mux.polyfnx(a.sa, x_UL_sa_trans, x_LL_sa_trans)) %>% 
  
  ##--- laboratory calculations ---###
  ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
  #(note that if mixed particles were used, a different equation must be used)
  mutate(mu.sa.mono = case_when(
    polydispersity == "monodisperse" ~ particle.surface.area.um2, # use reported surface area in monodisperse
    polydispersity == "polydisperse" ~  mux.polyfnx(a.x = a.sa, 
                                  x_LL = particle.surface.area.um2.min,
                                  x_UL = particle.surface.area.um2.max))) %>% 
  
   #calculate polydisperse effect concentration for surface area (particles/mL)
  mutate(EC_poly_sa.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.sa.mono)/mu.sa.poly_trans) %>%  
  #calculate environmentally realistic effect threshold
  mutate(EC_env_sa.particles.mL_trans = EC_poly_sa.particles.mL_trans * CF_bio_trans) %>% 
  
  ##### FOOD DILUTION ####
  # define upper size length for ingestion 
  mutate(x2M_ingest = case_when(is.na(max.size.ingest.um) ~ x2D_set, 
                         max.size.ingest.um < x2D_set ~ max.size.ingest.um,
                         max.size.ingest.um > x2D_set ~ x2D_set
                         )) %>%  #set to 5,000 as upper limit or max size ingest, whichever is smaller
 # calculate effect threshold for particles
  mutate(EC_mono_p.particles.mL_ingest = dose.particles.mL.master) %>% 
  mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
  mutate(mu.p.poly_ingest = mux.polyfnx(a.x = alpha, #alpha for particles
                                 x_UL= x2M_ingest, #upper ingestible size limit
                                 x_LL = x1M_set)) %>% 
  # polydisperse effect threshold for particles
  mutate(EC_poly_p.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.p.mono)/mu.p.poly_ingest) %>% 
   #calculate CF_bio for all conversions
  mutate(CF_bio_ingest = CFfnx(x1M = x1M_set,#lower size bin
                        x2M = x2M_ingest, #upper ingestible length
                        x1D = x1D_set, #default
                        x2D = x2D_set,  #default upper size range
                        a = alpha)) %>%  
  ## Calculate environmentally relevant effect threshold for particles
  mutate(EC_env_p.particles.mL_ingest = EC_poly_p.particles.mL_ingest * CF_bio_ingest) %>%  #aligned particle effect concentraiton (1-5000 um)
  
  
  #### volume ERM ####
##--- environmental calculations ---###
  #calculate lower ingestible volume 
  mutate(x_LL_v_ingest = volumefnx_poly(length = x1D_set,
                                 width = x1D_set)) %>% 
  #calculate maximum ingestible volume 
  mutate(x_UL_v_ingest = volumefnx_poly(length = x2M_ingest, # length-limited
                                 #x2D_set, #upper definiton (accouunts for fibers) CONSERVATIVE
                                 width = x2M_ingest)) %>% #ingestion-limited
  # calculate mu.v.poly
  mutate(mu.v.poly_ingest = mux.polyfnx(a.v, x_UL_v_ingest, x_LL_v_ingest)) %>% 
  ##--- laboratory calculations ---###
  ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
  #(note that if mixed particles were used, a different equation must be used)
  mutate(mu.v.mono = case_when(
    polydispersity == "monodisperse" ~ particle.volume.um3, # use reported volume in monodisperse
    polydispersity == "polydisperse" ~ mux.polyfnx(a.x = a.v, 
                                                   x_LL = particle.volume.um3.min,
                                                   x_UL = particle.volume.um3.max))) %>% 
  
  #calculate polydisperse effect concentration for volume (particles/mL)
  mutate(EC_poly_v.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.v.mono)/mu.v.poly_ingest) %>%  
    #calculate environmentally realistic effect threshold
  mutate(EC_env_v.particles.mL_ingest = EC_poly_v.particles.mL_ingest * CF_bio_ingest) %>% 
  
   ###### CLEANUP #####
  mutate(particles.mL.ox.stress = EC_env_sa.particles.mL_trans,
         particles.mL.food.dilution = EC_env_v.particles.mL_ingest)
```

###### Save Aligned dataset
```{r}
#saveRDS(aoc_final,"G:/My Drive/MooreInstitute/Projects/ToMEx2.0_EcoToxRisk/data/output/aoc_final.RDS")

saveRDS(aoc_final,
        "../data/output/aoc_final.RDS")
```


####Test to see if same thresholds attained in main risk calculation
##### SSD Functions
```{r}
#### define function for SSD generation for tier 1 ####
SSD_function_t1 <- function(filtered.data, hcxlcl){
  set.seed(99)
  #data collapse
collapsed <- filtered.data %>% 
  group_by(Species, Group) %>% 
  summarize(Conc = quantile(dose_new, 0.25))
#fit distributions
dists <- ssd_fit_dists(collapsed, left = "Conc", dists = c("weibull", "llogis", "lnorm", "gamma", "lgumbel"), computable = FALSE, silent = FALSE) 
#use average distribution with weighthing based on AICC
preds <- predict(dists, average = TRUE, 
                 #ic = "aicc",
                 nboot = 10, ci= TRUE) 
#report HC metrics of interest
hc5lcl <- c(preds$lcl[hcxlcl]) #CI95
#values to extract
print(hc5lcl)
}

# Leave-one-out by study function
sensitivity_t1 <- Vectorize(function(x, y) {
  train <- filtered.data[!filtered.data$doi %in% x,]
   SSD_function_t1(train, hcxlcl = y)
})

#### define function for SSD generation for tier 2 ####
SSD_function_t2 <- function(filtered.data, hcx){
  set.seed(99)
  #data collapse
collapsed <- filtered.data %>% 
  group_by(Species, Group) %>% 
  summarize(Conc = quantile(dose_new, 0.25))
#fit distributions
dists <- ssd_fit_dists(collapsed, left = "Conc", dists = c("weibull", "llogis", "lnorm", "gamma", "lgumbel"), computable = FALSE, silent = FALSE) 
#use average distribution with weighthing based on AICC
preds <- predict(dists, average = TRUE,# ic = "aicc",
                 nboot = 10, ci= TRUE) 
#report HC metrics of interest
hc <- c(preds$est[hcx]) #HC5
#values to extract
#print(hc5)
print(hc)
}

#### define function for SSD generation for tiers 3 and 4 ####
SSD_function_t3_4 <- function(filtered.data, hcx){
  set.seed(99)
  #data collapse
collapsed <- filtered.data %>% 
  #filter specific things for tiers 3 and 4
   filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population")) %>% 
  group_by(Species, Group) %>% 
  summarize(Conc = quantile(dose_new, 0.50))
#fit distributions
dists <- ssd_fit_dists(collapsed, left = "Conc", dists = c("weibull", "llogis", "lnorm", "gamma", "lgumbel"), computable = FALSE, silent = FALSE) 
#use average distribution with weighthing based on AICC
preds <- predict(dists, average = TRUE, 
                 #ic = "aicc", 
                 nboot = 10, ci= TRUE) 
#report HC metrics of interest
hc <- c(preds$est[hcx]) #HC5
#values to extract
#print(hc5)
print(hc)
}
```


##### Base Thresholds
```{r}
#filter out risk criteria (not done above)#
aoc_risk_paper <- aoc_final %>% 
  drop_na(effect.metric) %>% 
   filter(
     tier_zero_tech_f == ("Red Criteria Passed"))

####---- TISSUE TRANSLOCATION ------#####
filtered.data.small.default_t1.2 <- aoc_risk_paper %>% 
          mutate(dose_new = particles.mL.ox.stress / (af.time * af.noec)) %>%  
         drop_na(dose_new) %>% 
         mutate(dose_new = dose_new * 1000) %>% #convert particles/mL to particles/L
  filter(between(size.length.um.used.for.conversions, 1, upper.tissue.trans.size.um),
         shape_f != "Not Reported",
         poly_f != "Not Reported",
         !environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC")

filtered.data.small.default_t3.4 <- filtered.data.small.default_t1.2 %>% 
 filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"))

# get thresholds
small.default.t1 <- SSD_function_t1(filtered.data = filtered.data.small.default_t1.2, hcxlcl = 5)
small.default.t2 <- SSD_function_t2(filtered.data = filtered.data.small.default_t1.2, hcx = 5)
small.default.t3 <- SSD_function_t3_4(filtered.data = filtered.data.small.default_t3.4, hcx = 5)
small.default.t4 <- SSD_function_t3_4(filtered.data = filtered.data.small.default_t3.4, hcx = 10)

####---- Food Dilution ------#####
filtered.data.large.default_t1.2 <- aoc_risk_paper %>% 
   # remove algae, as food dilution MOE doesn't make sense for algae
  filter(Group != "Algae") %>% 
         mutate(dose_new = particles.mL.food.dilution / (af.time * af.noec)) %>%  
         drop_na(dose_new) %>% 
         mutate(dose_new = dose_new * 1000) %>% #convert particles/mL to particles/L
  filter(between(size.length.um.used.for.conversions, x1D_set, x2D_set),
         poly_f != "Not Reported",
         !environment %in% c("Terrestrial", "Not Reported"),
         Group != "Bacterium",
         Group != "Plant",
         effect.metric != "HONEC")

filtered.data.large.default_t3.4 <- filtered.data.large.default_t1.2 %>% 
 filter(risk.13 != 1,
         bio_f %in% c("Organism", "Population"))

# get thresholds
large.default.t1 <- SSD_function_t1(filtered.data = filtered.data.large.default_t1.2, hcxlcl = 5)
large.default.t2 <- SSD_function_t2(filtered.data = filtered.data.large.default_t1.2, hcx = 5)
large.default.t3 <- SSD_function_t3_4(filtered.data = filtered.data.large.default_t3.4, hcx = 5)
large.default.t4 <- SSD_function_t3_4(filtered.data = filtered.data.large.default_t3.4, hcx = 10)

base_thresholds <- tibble(
  "Tier" = c('Tier1', 'Tier2', 'Tier3', 'Tier4'),
  "Tissue Translocation (Default)" = c(small.default.t1, small.default.t2, small.default.t3, small.default.t4),
  "Food Dilution (Default)" = c(large.default.t1, large.default.t2, large.default.t3, large.default.t4))

base_thresholds
```
![Agreed-upon framework](assets/treshold_framework.png)

**Threshold 1:**
*HC*: HC5
*Data collapsing*: 1st quartile
*Point estimate*: lower 95% (of distribution)
*Biological scale of endpoints*: molecular to population

**Threshold 2:**
*HC*: HC5
*Data collapsing*: 1st quartile
*Point estimate*: median (of distribution)
*Biological scale of endpoints*: molecular to population

**Threshold 3:**
*HC*: HC5
*Data collapsing*: median
*Point estimate*: median
*Biological scale of endpoints*: organismal and population

**Threshold 4:**
*HC*: HC10
*Data collapsing*: median
*Point estimate*: median
*Biological scale of endpoints*: organismal and population

The figure above displays the working threshold framework for the ambient threshold group for the Microplastics Health Effects Workshop. 

The current framework for generating SSDs includes the following parameters:

Data pertaining to only aquatic organisms are included (marine and freshwater).  

All taxa are included with the exception of bacterium and plants.  

HONEC (Highest Observed No Effect Concentration) are excluded.  

Assessment factors are applied to convert all other effect metrics into NOECs:

![](../assets/AF_EM.png)

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)  

Assessment factors are applied to convert acute data into chronic:  

![](../assets/AF_chronic.png)

Green rows are from Wigger et al. 2020. Grey rows were agreed upon by the ambient threshold working group.

Reference: Wigger et al. 2020 (doi: 10.1002/ieam.4214)

Note: Values may be slightly different than those presented in the shiny app as concentrations are converted from particles/mL to particles/L ahead of calculations.


## Monte Carlo Alignments
### Base values
```{r}
# number of Monte-Carlo Simluaitons
n_sim <- 10 #probably should do 10,000 for final assessment, but keep number low for beta-testing 

###define sizes for alignment##
x1M_set <- 1 #um lower size for all alignments
x1D_set <- 1 #um lower size for all alignments
x2D_set <- 5000 #um
upper.tissue.trans.size.um <- 83 #10 #um #set size for x2M
```

### PDF Distributions
Values from Kooi et al (2021) supplementary information.
https://linkinghub.elsevier.com/retrieve/pii/S0043135421006278 
```{r}
## parametrization ##
# Define params for correction #
alpha = 2.07 #table s4 for marine surface water. length
alpha.sd = 0.07 #table s4 for marine surface water. lengthj
alpha_samples <- rnorm(n_sim, mean = alpha, sd = alpha.sd)

# define parameters for power law coefficients
a.sa = 1.5 #marine surface area power law
a.sa.sd = 0.009 #marine surface water surface area power law - table s4
a.sa_samples <- rnorm(n_sim, mean = a.sa, sd = a.sa.sd)

a.v = 1.48 #a_V for marine surface water volume
a.v.sd = 0.063
a.v_samples <- rnorm(n_sim, mean = a.v, sd = a.v.sd)

a.m = 1.32 # upper limit fora_m for mass for marine surface water in table S4 
a.m.sd = 0.009
a.m_samples <- rnorm(n_sim, mean = a.m, sd = a.m.sd)

a.ssa = 1.98 # A_SSA for marine surface water
a.ssa.sd = 0.297
a.ssa_samples <- rnorm(n_sim, mean = a.ssa, sd = a.ssa.sd)

#define additional parameters for calculations based on averages in the environment
R.ave = 0.77 #average width to length ratio for microplastics in marine enviornment
R.ave.sd = 0.29 #Tablse s3. Marine surfac water
R.ave_samples <- rnorm(n_sim, mean = R.ave, sd = R.ave.sd)

p.ave = 1.10 #average density in marine surface water
p.ave.sd = 0.14 #Tablse s3. Marine surfac water
p.ave_samples <- rnorm(n_sim, mean = p.ave, sd = p.ave.sd)
```


### Alignment Monte-Carlo Simulation
```{r}
#initiate empty list
MC_results <- vector("list", n_sim)

for (i in 1:n_sim) {

  #parameters to iterate
   alpha <- alpha_samples[i]
   a.sa <- a.sa_samples[i]
   a.v <- a.v_samples[i]
   a.m <- a.m_samples[i]
   a.ssa <- a.ssa_samples[i]
  # R.ave <- R.ave_samples[i] #not used
  # p.ave <- p.ave_samples[i] #not used

# calculate ERM for each species
aoc_final <- aoc_intermediate  %>% 
   #### TISSUE TRANSLOCATION ####
# define upper size length for Translocation 
#set to 83um for upper limit or max size ingest, whichever is smaller
mutate(x2M_trans = case_when(is.na(max.size.ingest.um) ~ upper.tissue.trans.size.um, 
                             max.size.ingest.um  < upper.tissue.trans.size.um ~  max.size.ingest.um,
                             max.size.ingest.um  > upper.tissue.trans.size.um ~ upper.tissue.trans.size.um)) %>% 
  
 # calculate effect threshold for particles
  mutate(EC_mono_p.particles.mL_trans = dose.particles.mL.master) %>% 
  mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
  mutate(mu.p.poly_trans = mux.polyfnx(a.x = alpha, #alpha for particles
                                 x_UL= x2M_trans, #upper ingestible size limit (width of particle)
                                 x_LL = x1M_set)) %>% 
  # polydisperse effect threshold for particles
  mutate(EC_poly_p.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.p.mono)/mu.p.poly_trans) %>% 
   #calculate CF_bio for all conversions
  mutate(CF_bio_trans = CFfnx(x1M = x1M_set,#lower size bin
                        x2M = x2M_trans, #upper translocatable
                        x1D = x1D_set, #default
                        x2D = x2D_set,  #default
                        a = alpha)) %>%  
  ## Calculate environmentally relevant effect threshold for particles
  mutate(EC_env_p.particles.mL_trans = EC_poly_p.particles.mL_trans * CF_bio_trans) %>%  #aligned particle effect concentraiton (1-5000 um)
  
  #### Surface area ERM ####
##--- environmental calculations ---###
  #calculate lower translocatable surface area
  mutate(x_LL_sa_trans = SAfnx(a = 0.5 * x1D_set, #length
                               b = 0.5 * x1D_set, #0.5 * R.ave * x1D_set, #width
                               c = 0.5 * x1D_set  #0.5 * R.ave * 0.67 * x1D_set #height
                               )) %>%  
  #calculate upper translocatable surface area
  mutate(x_UL_sa_trans = SAfnx(a = 0.5 * x2M_trans, 
                               b = 0.5 * x2M_trans, #width #0.5 * R.ave * x2M, 
                               c = 0.5 * x2M_trans #heigth #0.5 * R.ave * 0.67 * x2M
                               )) %>%  
  #calculate mu_x_poly (env) for surface area
  mutate(mu.sa.poly_trans = mux.polyfnx(a.sa, x_UL_sa_trans, x_LL_sa_trans)) %>% 
  
  ##--- laboratory calculations ---###
  ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
  #(note that if mixed particles were used, a different equation must be used)
  mutate(mu.sa.mono = case_when(
    polydispersity == "monodisperse" ~ particle.surface.area.um2, # use reported surface area in monodisperse
    polydispersity == "polydisperse" ~  mux.polyfnx(a.x = a.sa, 
                                  x_LL = particle.surface.area.um2.min,
                                  x_UL = particle.surface.area.um2.max))) %>% 
  
   #calculate polydisperse effect concentration for surface area (particles/mL)
  mutate(EC_poly_sa.particles.mL_trans = (EC_mono_p.particles.mL_trans * mu.sa.mono)/mu.sa.poly_trans) %>%  
  #calculate environmentally realistic effect threshold
  mutate(EC_env_sa.particles.mL_trans = EC_poly_sa.particles.mL_trans * CF_bio_trans) %>% 
  
  ##### FOOD DILUTION ####
  # define upper size length for ingestion 
  mutate(x2M_ingest = case_when(is.na(max.size.ingest.um) ~ x2D_set, 
                         max.size.ingest.um < x2D_set ~ max.size.ingest.um,
                         max.size.ingest.um > x2D_set ~ x2D_set
                         )) %>%  #set to 5,000 as upper limit or max size ingest, whichever is smaller
 # calculate effect threshold for particles
  mutate(EC_mono_p.particles.mL_ingest = dose.particles.mL.master) %>% 
  mutate(mu.p.mono = 1) %>% #mu_x_mono is always 1 for particles to particles
  mutate(mu.p.poly_ingest = mux.polyfnx(a.x = alpha, #alpha for particles
                                 x_UL= x2M_ingest, #upper ingestible size limit
                                 x_LL = x1M_set)) %>% 
  # polydisperse effect threshold for particles
  mutate(EC_poly_p.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.p.mono)/mu.p.poly_ingest) %>% 
   #calculate CF_bio for all conversions
  mutate(CF_bio_ingest = CFfnx(x1M = x1M_set,#lower size bin
                        x2M = x2M_ingest, #upper ingestible length
                        x1D = x1D_set, #default
                        x2D = x2D_set,  #default upper size range
                        a = alpha)) %>%  
  ## Calculate environmentally relevant effect threshold for particles
  mutate(EC_env_p.particles.mL_ingest = EC_poly_p.particles.mL_ingest * CF_bio_ingest) %>%  #aligned particle effect concentraiton (1-5000 um)
  
  
  #### volume ERM ####
##--- environmental calculations ---###
  #calculate lower ingestible volume 
  mutate(x_LL_v_ingest = volumefnx_poly(length = x1D_set,
                                 width = x1D_set)) %>% 
  #calculate maximum ingestible volume 
  mutate(x_UL_v_ingest = volumefnx_poly(length = x2M_ingest, # length-limited
                                 #x2D_set, #upper definiton (accouunts for fibers) CONSERVATIVE
                                 width = x2M_ingest)) %>% #ingestion-limited
  # calculate mu.v.poly
  mutate(mu.v.poly_ingest = mux.polyfnx(a.v, x_UL_v_ingest, x_LL_v_ingest)) %>% 
  ##--- laboratory calculations ---###
  ## define mu_x_mono OR mu_x_poly (lab) for alignment to ERM  #
  #(note that if mixed particles were used, a different equation must be used)
  mutate(mu.v.mono = case_when(
    polydispersity == "monodisperse" ~ particle.volume.um3, # use reported volume in monodisperse
    polydispersity == "polydisperse" ~ mux.polyfnx(a.x = a.v, 
                                                   x_LL = particle.volume.um3.min,
                                                   x_UL = particle.volume.um3.max))) %>% 
  
  #calculate polydisperse effect concentration for volume (particles/mL)
  mutate(EC_poly_v.particles.mL_ingest = (EC_mono_p.particles.mL_ingest * mu.v.mono)/mu.v.poly_ingest) %>%  
    #calculate environmentally realistic effect threshold
  mutate(EC_env_v.particles.mL_ingest = EC_poly_v.particles.mL_ingest * CF_bio_ingest) %>% 
   ###### CLEANUP #####
  mutate(particles.mL.ox.stress = EC_env_sa.particles.mL_trans,
         particles.mL.food.dilution = EC_env_v.particles.mL_ingest) %>% 
  # some values are empty (this is a problem that we need to address - there shouldn't be so many)
  drop_na(particles.mL.food.dilution,
          particles.mL.ox.stress)

#store results in a list
 # Store results in a list
  MC_results[[i]] <- list(particles_mL_ox_stress = aoc_final$particles.mL.ox.stress,
                          particles_mL_food_dilution = aoc_final$particles.mL.food.dilution,
                          rowid = aoc_final$rowid)
}
```
Convert to coefficient of variation:

The coefficient of variation is calculated as the ratio of the standard deviation to the mean of the dataset: CoV= μ / σ

```{r}
## STEP 1: 
# Create a dataframe from the list
results_df <- do.call(rbind, lapply(MC_results, function(x) {
  data.frame(
    rowid = x$rowid,
    particles_mL_ox_stress = x$particles_mL_ox_stress,
    particles_mL_food_dilution = x$particles_mL_food_dilution
  )
}))

# Convert factors to numeric if necessary
results_df$particles_mL_ox_stress <- as.numeric(as.character(results_df$particles_mL_ox_stress))
results_df$particles_mL_food_dilution <- as.numeric(as.character(results_df$particles_mL_food_dilution))

## Step 2:
# Calculate CoV
cov_results <- results_df %>%
  group_by(rowid) %>%
  summarise(
    CoV_ox_stress = sd(particles_mL_ox_stress, na.rm = TRUE) / mean(particles_mL_ox_stress, na.rm = TRUE),
    CoV_food_dilution = sd(particles_mL_food_dilution, na.rm = TRUE) / mean(particles_mL_food_dilution, na.rm = TRUE)
  )

# View the results
print(cov_results)


# Step 3:
# Assuming original_data is your original dataset
aoc_MC <- merge(aoc_final, cov_results, by = "rowid", all.x = TRUE)
```



# Probabilistic Species Sensitivity Distribution Plus

```{r eval=TRUE, include=FALSE}
#food dilution
tier1_2_food <- filtered.data.large.default_t1.2
tier3_4_food <- filtered.data.large.default_t3.4

#tissue translocation
tier1_2_tissue <- filtered.data.small.default_t1.2
tier3_4_tissue <- filtered.data.small.default_t3.4
```

```{r eval=TRUE, include=FALSE}
# -------------------------------------------------------------------------------------------------
# Code based on PSSD and PNEC calculations using the tool PSSD+ developed by Wigger et al. (2019)
# -------------------------------------------------------------------------------------------------
# 
# Associated publication: Systematic consideration of parameter uncertainty and variability in
#                         probabilistic species sensitivity distributions
# 
# Authors: Henning Wigger, Delphine Kawecki, Bernd Nowack and V?ronique Adam
# 
# Institute: Empa, Swiss Federal Laboratories for Materials Science and Technology,
#            Technology and Society Laboratory, Lerchenfeldstrasse 5, 9014 St. Gallen, Switzerland
# 
# submitted to Integrated Environmental Assessment and Management in December 2018
# 
# -------------------------------------------------------------------------------------------------

##### Build fun4ctions ####
getwd()
source("PSSD/rmore.r")
source("PSSD/do.pssd.r")
#source("PSSD/do.pssd.troph.r")
#source("PSSD/do.pssd.ag.r")


###################################################################################################
##### MAIN PARAMETERS FOR THE CALCULATION #########################################################
###################################################################################################

# number of simulations for the triangular distributions of the data points and uncertainty factors
SIM <- 1000 #10 is minimum, 10,000 is recommended

# coefficient of variation for the data point distributions
CV.DP <- 0.3 #this arbitray value should be changed to the matrix corresponding to the actual CV for each datapoint, which is calculated above. 

# coefficient of variation for the uncertainty factor distributions
CV.UF <- 0.5 #unclear how this value was derived... I believe it corresponds to the combined uncertainties of the effect metric uncertainty facotr (e.g., LOEC to NOEC, etc.) and the acute to chronic uncertainty factor... maybe just leave as-is for now?
```

## Functions
### Data Preparation
```{r}
#FUnction to process data
prep_data <- function(data) {
  # Base part of the names used for returned list elements
  names <- c("DP", "UFt", "UFdd", "doseDescriptor", "polymer", "shape", "environment", "group")
  
  # Data processing steps
  matrices <- list(
    DP = data %>% mutate(id = row_number()) %>%
        mutate(particles_L = dose_new * 1000) %>% #particles/mL * 1000 = particles/L
        select(id, Species, particles_L) %>%
        acast(id ~ Species, value.var = "particles_L") %>%
        Matrix(sparse = TRUE),
    UFt = data %>% mutate(id = row_number()) %>%
        select(id, Species, af.time) %>%
        acast(id ~ Species, value.var = "af.time") %>% 
        Matrix(sparse = T),
    UFdd = data %>% mutate(id = row_number()) %>% 
        select(id, Species, af.noec) %>% 
        acast(id ~ Species, value.var = "af.noec") %>% 
        Matrix(sparse = T),
    doseDescriptor <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, effect.metric) %>% 
      acast(id ~ Species, value.var = "effect.metric") %>% 
      Matrix(sparse = T),
    polymer_matrix <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, poly_f) %>% 
      acast(id ~ Species, value.var = "poly_f") %>% 
      Matrix(sparse = T),
    shape__matrix <- data %>% 
      mutate(id = row_number()) %>% 
      select(id, Species, shape_f) %>% 
      acast(id ~ Species, value.var = "shape_f") %>% 
      Matrix(sparse = T),
    env_matrix <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, environment) %>% 
      acast(id ~ Species, value.var = "environment") %>% 
      Matrix(sparse = T),
    group_matrix <- data %>% mutate(id = row_number()) %>% 
      select(id, Species, Group) %>% 
      acast(id ~ Species, value.var = "Group") %>% 
      Matrix(sparse = T)
  )
  
  # Rename the list elements based on constructed names
  names(matrices) <- names
  
  # Return the named list of matrices
  matrices
}

#example usage
#tier1_2_food_matrices <- prep_data(tier1_2_food)
```

### Run PSSD
```{r include=FALSE}
run_pSSD_analysis <- function(data_matrices, num_iterations, sim, cv_dp, cv_uf, data_name) {
  # Initialize an empty list to store the results
  pSSD_list <- vector("list", num_iterations)
  
  # Loop through each iteration
  for (i in 1:num_iterations) {
    pSSD_list[[i]] <- do.pSSD(
      DP = data_matrices[["DP"]],  # Correctly reference matrices with dynamic naming
      UFt = data_matrices[["UFt"]],
      UFdd = data_matrices[["UFdd"]],
      SIM = sim,
      CV.DP =  cv_dp,
      CV.UF = cv_uf
    )
  }
  
  # Combine all the results into a single object
  pSSD <- do.call(cbind, pSSD_list)
  
  # Save the combined results
  save(pSSD, file = paste0("PSSD/updated/",data_name,".RData"))
  
  # Calculate corrected endpoints
  corr_endpoints <- data_matrices[["DP"]] / (data_matrices[["UFt"]] * data_matrices[["UFdd"]])

  # Optionally return the corrected endpoints or any other result
  return(list(pSSD = pSSD, corr_endpoints = corr_endpoints))
}

# #example
# tier1_2_food_pssd <- run_pSSD_analysis(
#   data_matrices = tier1_2_food_matrices,
#   num_iterations = 10,
#   sim = SIM,
#   cv_dp = CV.DP,  # Example coefficient of variation for DP
#   cv_uf = CV.UF,  # Example coefficient of variation for UF
#   data_name = "tier1_2_food"
# )
```

###Plotting
#### Preparation Function
```{r}
prepare_plot_data <- function(pSSD, data_matrices, species_data_source) {
  # Ensure that the required matrices are present and correctly formatted
  if (is.null(data_matrices[['DP']]) || is.null(data_matrices[['UFdd']]) || is.null(data_matrices[['UFt']])) {
    stop("Data matrices for DP, UFdd, or UFt are not available or incorrect.")
  }

  # Define interpolation values
  iv <- seq(-5, 10, 0.001)
  ECDF.data <- matrix(NA, 10000, length(iv))
  
  # Compute ECDF for each column in pSSD
  for (i in 1:10000) {
    the.ecdf.f <- ecdf(log(pSSD[, i], base = 10))
    ECDF.data[i, ] <- the.ecdf.f(iv)
  }

  # Preparing dataframe for ggplot
  iv_vec <- seq(-5, 10, length.out = ncol(ECDF.data))
  ecdf_df <- data.frame(iv = rep(iv_vec, times = nrow(ECDF.data)), 
                        ecdf_value = as.vector(t(ECDF.data)))

  # Calculating quantiles for shading
  quantiles_df <- ecdf_df %>%
    group_by(iv) %>%
    summarise(min = min(ecdf_value, na.rm = TRUE),
              max = max(ecdf_value, na.rm = TRUE),
              q05 = quantile(ecdf_value, 0.05, na.rm = TRUE),
              q95 = quantile(ecdf_value, 0.95, na.rm = TRUE),
              q25 = quantile(ecdf_value, 0.25, na.rm = TRUE),
              q75 = quantile(ecdf_value, 0.75, na.rm = TRUE),
              mean = mean(ecdf_value, na.rm = TRUE)) %>%
    ungroup()

  # Calculate deterministic values of NOEC
  NOEC.det <- data_matrices[['DP']] / (data_matrices[['UFdd']] * data_matrices[['UFt']])
  
  # Calculate the geometric mean of NOEC
  if (ncol(NOEC.det) > 0 && nrow(NOEC.det) > 0) {
    NOEC.gmean <- apply(NOEC.det, 2, function(x) exp(mean(log(x), na.rm = TRUE)))
  } else {
    stop("NOEC.det matrix is empty or not properly formatted.")
  }
  
  # Creating a dataframe for ggplot with species data
  species_data <- data.frame(
    Species = colnames(NOEC.det),
    NOEC_log10 = log10(NOEC.gmean),
    NOEC = NOEC.gmean,
    Prop = rank(NOEC.gmean) / (length(NOEC.gmean) + 1)
  )

  # Join metadata to species data
  species_data <- species_data %>% 
    left_join(species_data_source %>% distinct(Group, Species), by = "Species") %>% 
    left_join(species_data_source %>% distinct(Species, environment), by = "Species")

  list(quantiles_df = quantiles_df, species_data = species_data)
}

# Example usage
# tier1_2_food_plot_prep <- prepare_plot_data(pSSD = tier1_2_food_pssd$pSSD, 
#                                data_matrices = tier1_2_food_matrices, 
#                                species_data_source = tier1_2_food)

```


#### PSSD ggplot Function
```{r}

pSSD_plot <-  function(quantiles_df = quantiles_df, species_data = species_data, data_name = data_name){
ggplot() +
  geom_ribbon(data = quantiles_df, aes(x = iv, ymin = min, ymax = max), fill = "coral", alpha = 0.1) +
  geom_ribbon(data = quantiles_df, aes(x = iv, ymin = q05, ymax = q95), fill = "coral", alpha = 0.3) +
  geom_ribbon(data = quantiles_df, aes(x = iv, ymin = q25, ymax = q75), fill = "coral", alpha = 0.8) +
  geom_point(data = species_data, aes(x = NOEC_log10, y = Prop, color = Group)) +
  geom_text(data = species_data, aes(x = NOEC_log10, y = Prop, label = Species, color = Group), 
            hjust = -0.2, vjust = 0,
            fontface = "italic",
            family = "helvetica"
            ) +
  geom_line(data = quantiles_df, aes(x = iv, y = mean), color = "firebrick4", size = 1) +
  scale_x_continuous(name = "NOEC (particles/L)", breaks = c(-4, -2, 0, 2, 4, 6, 8,10),
                     labels = expression(10^-4, 10^-2, 1, 10^2, 10^4, 10^6, 10^8, 10^10),
                     limits = c(-4, 10)) +
  scale_y_continuous(name = "Cumulative probability", limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
  fill.type +
    color.type +
  labs(title = ("Microplastics Probabilistic Species Sensitivity Distribution"),
       subtitle = data_name) +
    theme.type
 # dark_theme_minimal(base_size = 15) 
 }

# example usage
# pSSD_plot(quantiles_df = tier1_2_food_plot_prep$quantiles_df,
#           species_data = tier1_2_food_plot_prep$species_data,
#           data_name = "Tier 2 (Food Dilution)")

```

#### PNEC ggplot Function
```{r}
# Calculate PNEC1 if not already calculated
PNEC_plot <- function(pssd_results, hcx, data_name){
  PNEC <- apply(pssd_results$pSSD, 2, function(x) quantile(x, probs = hcx, type = 1))
  # Convert PNEC1 to a dataframe for ggplot
  PNEC_df <- data.frame(PNEC = PNEC)
  
  # Plotting
  ggplot(PNEC_df, aes(x = PNEC)) +
    geom_histogram(aes(y = ..density..), fill = rgb(255, 127, 80, max = 255, alpha = 50), color = "coral",
                   bins = 100)   +
    labs(x = "PNEC (Particles/L)", y = "Probability density", title = "Probability density of the PNEC",
         subtitle = data_name) +
    #theme_minimal() +
    geom_density(col = "red", lwd = 1) +  # Optionally add a density line
    theme.type
   # dark_theme_minimal(base_size = 18)
}

#example
# PNEC_plot(pssd_results = tier1_2_food_pssd,
#            hcx = 0.05
#           data_name = "Tier 2 (Food Dilution)")
```
#### PNEC Data Summary
```{r}
  # Mode calculation using density
Mode_Y <- function(x) {
  dens <- density(x)
  ind <- which(dens$y == max(dens$y))
  return(dens$x[ind])
}

#PNEC Data summary function
PNEC_data_summary <- function(pssd_results, hcx, data_name){

PNEC <- apply(pssd_results$pSSD, 2, function(x) quantile(x, probs = hcx, type = 1))
PNEC_df <- data.frame(PNEC = PNEC)
  
# Calculate statistics for PNEC1
Stat_PNEC <- data.frame(
  Min = min(PNEC),
  Q5 = quantile(PNEC, 0.05),
  Q25 = quantile(PNEC, 0.25),
  Mean = mean(PNEC),
  Median = median(PNEC),
  Mode = Mode_Y(PNEC),
  Q75 = quantile(PNEC, 0.75),
  Q95 = quantile(PNEC, 0.95),
  Max = max(PNEC)
)

# Transposing for similar structure to your matrix
Stat_PNEC_t <- t(Stat_PNEC)
colnames(Stat_PNEC_t) <- paste0(data_name, " - HC", hcx*100)

return(list("stats" = as.data.frame(Stat_PNEC_t),
            "df" = PNEC_df))
}


## example
# tier1_2_food_PNEC <- PNEC_data_summary(pssd_results = tier1_2_food_pssd,
#                                        hcx = 0.05,
#                                        data_name = "Tier 2 (Food Dilution)")
# 
# tier1_2_food_PNEC$df
# tier1_2_food_PNEC$stats
```

## Application
### Tier 1_food
```{r include=FALSE}
#Step 1: prep data matrices
tier1_2_food_matrices <- prep_data(tier1_2_food)

#Step 2: run pSSD
tier1_2_food_pssd <- run_pSSD_analysis(
  data_matrices = tier1_2_food_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP,  # Default coefficeint
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier1_2_food"
)

#Step 3: prep for ggplot
tier1_2_food_plot_prep <- prepare_plot_data(pSSD = tier1_2_food_pssd$pSSD,
                                            data_matrices = tier1_2_food_matrices,
                                            species_data_source = tier1_2_food)

#Step 4a: generate ggplot (pSSD)
tier1_2_food_pssdPlot <-  pSSD_plot(quantiles_df = tier1_2_food_plot_prep$quantiles_df,
                                    species_data = tier1_2_food_plot_prep$species_data,
                                    data_name = "Tier 2 (Food Dilution)")

#Step 4b: generate ggplot (PNEC)
tier1_2_food_PNECPlot <-  PNEC_plot(pssd_results = tier1_2_food_pssd,
                                    hcx = 0.05,
                                    data_name = "Tier 2 (Food Dilution)")

# Step 5: extract PNEC values for table
tier1_2_food_PNEC_summary <- PNEC_data_summary(pssd_results = tier1_2_food_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 2 (Food Dilution)")
```

```{r}
ggarrange(tier1_2_food_pssdPlot,tier1_2_food_PNECPlot,
          ncol = 1)
```
```{r}
tier1_2_food_PNEC_summary$stats
```

### Tiers 3 and 4_food
```{r include=FALSE}
#Step 1: prep data matrices
tier3_4_food_matrices <- prep_data(tier3_4_food)

#Step 2: run pSSD
tier3_4_food_pssd <- run_pSSD_analysis(
  data_matrices = tier3_4_food_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP,  # Example coefficient of variation for DP
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier3_4_food"
)

#Step 3: prep for ggplot
tier3_4_food_plot_prep <- prepare_plot_data(pSSD = tier3_4_food_pssd$pSSD,
                                            data_matrices = tier3_4_food_matrices,
                                            species_data_source = tier3_4_food)

#Step 4a: generate ggplot (pSSD)
tier3_4_food_pssdPlot <-  pSSD_plot(quantiles_df = tier3_4_food_plot_prep$quantiles_df,
                                    species_data = tier3_4_food_plot_prep$species_data,
                                    data_name = "Tier 3 (Food Dilution)")

#Step 4b: generate ggplot (PNEC)
tier3_food_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_pssd,
                                    hcx = 0.05,
                                    data_name = "Tier 3 (Food Dilution)")

tier4_food_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_pssd,
                                    hcx = 0.10,
                                    data_name = "Tier 4 (Food Dilution)")

# Step 5: extract PNEC values for table
tier3_food_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 3 (Food Dilution)")

tier4_food_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_pssd,
                                               hcx = 0.10,
                                               data_name = "Tier 4 (Food Dilution)")
```

```{r}
food_plots <- ggarrange(tier3_4_food_pssdPlot,  
                        ggarrange(tier3_food_PNECPlot,
                                  tier4_food_PNECPlot,
                                  ncol = 2, nrow = 1),
                        ncol = 1, nrow = 2)

food_plots
```
```{r}
cbind(tier3_food_PNEC_summary$stats, tier4_food_PNEC_summary$stats)
```

### Tier 3 and 4_tissue
```{r include=FALSE}
#Step 1: prep data matrices
tier3_4_tissue_matrices <- prep_data(tier3_4_tissue)

#Step 2: run pSSD
tier3_4_tissue_pssd <- run_pSSD_analysis(
  data_matrices = tier3_4_tissue_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP,  # Example coefficient of variation for DP
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier3_4_tissue"
)

#Step 3: prep for ggplot
tier3_4_tissue_plot_prep <- prepare_plot_data(pSSD = tier3_4_tissue_pssd$pSSD,
                                            data_matrices = tier3_4_tissue_matrices,
                                            species_data_source = tier3_4_tissue)

#Step 4a: generate ggplot (pSSD)
tier3_4_tissue_pssdPlot <-  pSSD_plot(quantiles_df = tier3_4_tissue_plot_prep$quantiles_df,
                                    species_data = tier3_4_tissue_plot_prep$species_data,
                                    data_name = "Tier 3 (Tissue Translocation)")

#Step 4b: generate ggplot (PNEC)
tier3_tissue_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_tissue_pssd,
                                      hcx = 0.05,
                                      data_name = "Tier 3 (Tissue Translocation)")

tier4_tissue_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_tissue_pssd,
                                      hcx = 0.10,
                                      data_name = "Tier 3 (Tissue Translocation)")

# Step 5: extract PNEC values for table
tier3_tissue_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_tissue_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 3 (Tissue Translocation)")

tier4_tissue_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_tissue_pssd,
                                               hcx = 0.10,
                                               data_name = "Tier 4 (Tissue Translocation)")
```

```{r}
tissue_plots <- ggarrange(tier3_4_tissue_pssdPlot,  
                        ggarrange(tier3_tissue_PNECPlot,
                                  tier4_tissue_PNECPlot,
                                  ncol = 2, nrow = 1),
                        ncol = 1, nrow = 2)

tissue_plots
```

```{r}
cbind(tier3_tissue_PNEC_summary$stats, tier4_tissue_PNEC_summary$stats)
```

## Summary
### Table
```{r}
summary_table <- cbind(tier3_food_PNEC_summary$stats, tier4_food_PNEC_summary$stats,
                       tier3_tissue_PNEC_summary$stats, tier4_tissue_PNEC_summary$stats) %>% 
  mutate(across(where(is.numeric), round, digits = 3))

summary_table
```
```{r}
base_tissue <- data.frame(Tier = c("1", "2", "3", "4"),
                          ERM = "Tissue Translocation", 
                          PNEC = base_thresholds$`Tissue Translocation (Default)`)

base_food <- data.frame(Tier = c("1", "2", "3", "4"),
                          ERM = "Food Dilution", 
                          PNEC = base_thresholds$`Food Dilution (Default)`)

base_thesholds_df <- rbind(base_tissue, base_food)

base_thesholds_df
```
### Plot
```{r}
#data prep
t3f <- data.frame(ERM = "Food Dilution", Tier = "3",PNEC = tier3_food_PNEC_summary$df)
t4f <- data.frame(ERM = "Food Dilution", Tier = "4",PNEC = tier4_food_PNEC_summary$df)
t3t <- data.frame(ERM = "Tissue Translocation", Tier = "3",PNEC = tier3_tissue_PNEC_summary$df)
t4t <- data.frame(ERM = "Tissue Translocation", Tier = "4",PNEC = tier4_tissue_PNEC_summary$df)

## join DFs
PNEC_dfs <- rbind(t3f, t4f, t3t, t4t)

#plot
PNEC_boxPlot <- ggplot(data = PNEC_dfs, aes(x = PNEC, y = Tier, fill = ERM, color = ERM)) +
   geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), color = "white") +
   geom_jitter(width = 0.5, size = 1.5, alpha = 0.01) +  # Jittered points
   #geom_boxplot(width = 0.1, outlier.shape = NA, fill = NA) +  # Boxplot lines
   geom_point(data = base_thesholds_df %>% filter(Tier>2), aes(xintercept = PNEC, y = Tier, fill = ERM),
              size = 10, shape = 23, 
              color = "white",
              stroke = 1.5 #thickness of outline
              ) +
   scale_x_log10() +
    # geom_histogram(aes(y = ..density..), fill = rgb(255, 127, 80, max = 255, alpha = 50), color = "coral",
    #                bins = 100)   +
    #labs(x = "PNEC (Particles/L)", y = "Probability density", title = "Probability density of the PNEC",
     #    subtitle = data_name) +
    #theme_minimal() +
    dark_theme_minimal(base_size = 18)

PNEC_boxPlot
```
## Supplemental
### Freshwater Only
#### Data Filtering
```{r}
#food dilution
tier1_2_food_freshwater <- tier1_2_food %>% filter(environment == "Freshwater")
tier3_4_food_freshwater <- tier3_4_food %>% filter(environment == "Freshwater")

#tissue translocation
tier1_2_tissue_freshwater <- tier1_2_tissue %>% filter(environment == "Freshwater")
tier3_4_tissue_freshwater <- tier3_4_tissue %>% filter(environment == "Freshwater")
```
#### Processing
```{r}
### Food Dilution
#Step 1: prep data matrices
tier3_4_food_freshwater_matrices <- prep_data(tier3_4_food_freshwater)

#Step 2: run pSSD
tier3_4_food_freshwater_pssd <- run_pSSD_analysis(data_matrices = tier3_4_food_freshwater_matrices,
  num_iterations = 10,
  sim = SIM,
  cv_dp = CV.DP,  # Example coefficient of variation for DP
  cv_uf = CV.UF,  # Example coefficient of variation for UF
  data_name = "tier3_4_food_freshwater")

#Step 3: prep for ggplot
tier3_4_food_freshwater_plot_prep <- prepare_plot_data(pSSD = tier3_4_food_freshwater_pssd$pSSD,
                                            data_matrices = tier3_4_food_freshwater_matrices,
                                            species_data_source = tier3_4_food_freshwater)

#Step 4a: generate ggplot (pSSD)
tier3_4_food_freshwater_pssdPlot <-  pSSD_plot(quantiles_df = tier3_4_food_freshwater_plot_prep$quantiles_df,
                                    species_data = tier3_4_food_freshwater_plot_prep$species_data,
                                    data_name = "Tier 3 (Food Dilution - Freshwater Only)")

#Step 4b: generate ggplot (PNEC)
tier3_food_freshwater_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_freshwater_pssd,
                                             hcx = 0.05,
                                             data_name = "Tier 3 (Food Dilution - Freshwater Only)")

tier4_food_freshwater_PNECPlot <-  PNEC_plot(pssd_results = tier3_4_food_freshwater_pssd,
                                             hcx = 0.10,
                                             data_name = "Tier 4 (Food Dilution - Freshwater Only)")

# Step 5: extract PNEC values for table
tier3_food_freshwater_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_freshwater_pssd,
                                               hcx = 0.05,
                                               data_name = "Tier 3 (Food Dilution - Freshwater Only)")

tier4_food_freshwater_PNEC_summary <- PNEC_data_summary(pssd_results = tier3_4_food_freshwater_pssd,
                                               hcx = 0.10,
                                               data_name = "Tier 4 (Food Dilution - Freshwater Only)")

freshwater_food_plots <- ggarrange(tier3_4_food_freshwater_pssdPlot,  
                        ggarrange(tier3_food_freshwater_PNECPlot,
                                  tier4_food_freshwater_PNECPlot,
                                  ncol = 2, nrow = 1),
                        ncol = 1, nrow = 2)

freshwater_food_plots
```

