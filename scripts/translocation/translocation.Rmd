---
title: "Translocation"
author: "Scott Coffin"
date: "5/07/2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(readxl)
library(caret)
library(DALEX)
library(skimr)
library(ggeffects)
#library(ggdark)
```
# Setup
Adding info here to show diff
```{r}
getwd()
#data cleanup
Tissue_Translocation <- read_excel("../../data/input/translocation_scored_2.xlsx") %>% 
                                   #, sheet = "translocation_scored_2") %>% 
  mutate(Species = as.factor(Species)) %>% 
  mutate(Polymer = as.factor(Polymer)) %>% 
  mutate(lab.field = as.factor(lab.field)) %>% 
  mutate(Shape = as.factor(Shape)) %>%
  mutate(size.um = `Size (Âµm)`) %>% 
  mutate(size.nm = size.um * 1000) %>% 
  mutate(Organisms = as.factor(Organisms)) %>%
  mutate(Exposure_route = as.factor(Exposure_route)) %>% 
  mutate(Tissue = as.factor(Tissue)) %>% 
  mutate(translocated_10 = case_when(`Tissue translocation observed (Y/N)` == "Y" ~ 1,
                                     `Tissue translocation observed (Y/N)` == "N" ~ 0))

#select variables for model
df <- Tissue_Translocation %>% 
  select(c(translocated_10,
           Polymer,
           Shape,
           size.um,
           Organisms,
           lab.field,
           Exposure_route
           )) %>% 
  drop_na()
skim(df)
```
## Dataset  Exploration
```{r}
#Load aoc_z into dataframe. This file is generated from RDA_Maker.R
#Source("Tox Data/RDA_Maker.R")
aoc_z <- readRDS(file = "../../data/input/aoc_z_tomex2.RDS")
```



### Size
```{r}
summary(Tissue_Translocation$`Size (Âµm)`)
```

```{r}
#histogram
histogram <- Tissue_Translocation %>%  
  ggplot(aes(x = size.um)) + 
  geom_histogram(bins =19) + 
  scale_x_log10(name = expression(paste("Particle Length (", mu, "m)")),                                                                                               labels = scales::label_comma()) +
  theme_bw()
histogram
```
```{r}
ggsave(filename = "translocation_histogram.jpeg",
       path = "../../output/Manuscript_Figs/translocation", 
       plot =histogram, width = 5, height = 3, units = "in",
       bg = "white")
```


### Categorical Characteristics
#### Total studies
```{r}
Tissue_Translocation %>% 
  #group_by(Polymer) %>% 
  summarise(n_studies = n_distinct(doi)) %>% 
  arrange(desc(n_studies))
```

#### Binary translocation
```{r}
Tissue_Translocation %>% 
  group_by(`Tissue translocation observed (Y/N)`) %>% 
  summarise(n_studies = n_distinct(doi),
            n_datapoints = n()) %>% 
  arrange(desc(n_studies))
```

#### Polymer
```{r}
Tissue_Translocation %>% 
  mutate(Polymer = case_when(
    grepl("PVC", Polymer) ~ "PVC",
    grepl("PS", Polymer) ~ "PS",
    Polymer == "unreported" ~ "uncharacterized",
    Polymer == "HDPE" ~ "PE",
    Polymer == "MDPE" ~ "PE",
    Polymer == "Nylon" ~ "PA",
    T ~ Polymer
  )) %>% 
  group_by(Polymer) %>% 
  summarise(n_studies = n_distinct(doi),
            n_obs = n()) %>% 
  arrange(desc(n_studies))
```
#### Shape
```{r}
Tissue_Translocation %>% 
  group_by(Shape) %>% 
  summarise(n_studies = n_distinct(doi),
            n_observations = n()) %>% 
  arrange(desc(n_studies))
```
#### Species
```{r}
Tissue_Translocation %>% 
  group_by(Species) %>% 
  summarise(n_studies = n_distinct(doi)) %>% 
  arrange(desc(n_studies))
```
#### ORganism Group
```{r}
Tissue_Translocation %>% 
  group_by(Organisms) %>% 
  summarise(n_studies = n_distinct(doi),
            n_obs = n()) %>% 
  arrange(desc(n_studies))
```

#### Tissue
```{r}
Tissue_Translocation %>% 
  group_by(Tissue) %>% 
  summarise(n_studies = n_distinct(doi),
            n_obs = n()) %>% 
  arrange(desc(n_studies))
```

# Modelling
```{r}
translocation_glm <- Tissue_Translocation %>% 
ggplot(aes(x = size.um, y = translocated_10)) +
  stat_smooth(method="glm", method.args=list(family="binomial"), se=TRUE,
              color = "black") +
  geom_jitter(height = 0.1) +
  scale_x_log10(name = expression(paste("Particle Length (", mu, "m)")),
                labels = scales::label_comma()
                ) +#,
  #n.breaks = 10) +
  scale_y_continuous(name = "Particle Translocation Probability",
                     labels = scales::percent, limits = c(0,1)) +
  theme_classic(base_size = 16)
translocation_glm
```
```{r}
translocation_glm <- Tissue_Translocation %>% 
  ggplot(aes(x = size.um, y = translocated_10)) +
  stat_smooth(method = "glm", method.args = list(family = "binomial"), se = TRUE,
              color = "black") +
 # Add rug for binary 0 at the bottom
  geom_rug(
    data = Tissue_Translocation %>% filter(translocated_10 == 0),
    aes(x = size.um),
    sides = "b", # Rug on the bottom
    color = "darkblue", # Optional: color for binary 0
    alpha = 0.9, # Transparency
    length = unit(0.05, "npc") # Length of the rug marks
  ) +
  # Add rug for binary 1 at the top
  geom_rug(
    data = Tissue_Translocation %>% filter(translocated_10 == 1),
    aes(x = size.um),
    sides = "t", # Rug on the top
    color = "darkred", # Optional: color for binary 1
    alpha = 0.9, # Transparency
    length = unit(0.05, "npc") # Length of the rug marks
  ) +
  scale_x_log10(name = expression(paste("Particle Length (", mu, "m)")),
                labels = scales::label_comma()) +
  scale_y_continuous(name = "Particle Translocation Probability",
                     labels = scales::percent, limits = c(0, 1)) +
  theme_classic(base_size = 16)
translocation_glm
```



#### Manuscript Figure
```{r}
ggsave(filename = "translocation_glm.jpeg",
       path = "../../output/Manuscript_Figs/translocation",
       plot = translocation_glm, width = 6, height = 4, units = "in",
       bg = "white")
```

##logistic regression
```{r}
response <- as.numeric(as.character(df$translocated_10))
predictors <- as.data.frame(df %>% dplyr::select(-translocated_10))
#build glm
glm_model <- train(translocated_10~., data = df, method = "glm", family = "binomial")
#build explainer for easy interpretation
explainer_glm_model <- DALEX::explain(glm_model, label = "glm", data = predictors, y = response)

#classifier plot
classif_glm <- model_parts(explainer_glm_model, loss_function = loss_root_mean_square)
#plot classifier
plot(classif_glm)
```

```{r}
#partial dependence plot by dose
pdp_classif_glm  <- model_profile(explainer_glm_model, variable = "Polymer", type = "partial")
#partial dependence plot by particle surface area
pdp_classif_glm_2  <- model_profile(explainer_glm_model, variable = "Shape", type = "partial")
#partial dependence plot by particle length
pdp_classif_glm_length  <- model_profile(explainer_glm_model, variable = "size.um", type = "partial")
#partial dependence plot by polymer
pdp_classif_glm_polymer  <- model_profile(explainer_glm_model, variable = "Organisms", type = "partial")

plot(pdp_classif_glm,  pdp_classif_glm_2)

plot(pdp_classif_glm_polymer)
plot(pdp_classif_glm_length)
```
```{r}
summary(glm_model)
```
```{r}
#simpler model
simple <- glm(translocated_10 ~ size.um, data = df, family = "binomial")
summary(simple)

response <- as.numeric(as.character(df$translocated_10))
predictors <- as.data.frame(df %>% dplyr::select(size.um))

#build explainer for easy interpretation
explainer_glm_model <- DALEX::explain(glm_model, label = "glm", data = predictors, y = response)
```
```{r}
explainer_glm_model$model$metric
```
```{r}
explainer_glm_model$model
```

```{r}
library(jtools)
plot_summs(simple, scale = TRUE, inner_ci_level = 0.95, plot.distributions = TRUE)
```
```{r}
export_summs(simple, scale = TRUE,
             error_format = "[{conf.low}, {conf.high}]")
```

```{r}
size.model <- glm(translocated_10 ~ size.um, data = Tissue_Translocation, family = "binomial")
```


```{r}
obj <- ggeffects::ggpredict(simple, terms="size.um [all]")
plot(obj)
```
```{r}
size.model <- glm(translocated_10 ~ size.um, data = Tissue_Translocation, family = "binomial")
#generate distribution of data
mockData <- data.frame(
  size.um = (1:10000))

mockData_fitted <- predict(size.model,
                     mockData,
                     type = "response",
                     se.fit = TRUE) %>% 
  as.data.frame()

mock <- cbind(mockData, mockData_fitted) %>% 
  # model object nanometer has a component called linkinv that 
         # is a function that inverts the link function of the GLM:
  mutate(lower = exp(fit - 1.96 * se.fit)/( 1 + exp(fit - 1.96 * se.fit)),
         upper = exp(fit + 1.96 * se.fit)/( 1 + exp(fit + 1.96 * se.fit)))
  
#plot
translocation_glm <- mock %>% 
  ggplot(aes(x = size.um, 
             y = fit)) +
  geom_line(color = "blue") +
  geom_ribbon(aes(ymin = lower,
                  ymax = upper),
              alpha = 0.5) +
  # geom_point(aes(x = size.nm, y = translocated_10),
  #            data = Tissue_Translocation,
  #            alpha = 0.7) +
   # scale_x_continuous(name = "Particle Length (nm)",
   #                    limits = c(1, 400000),
   #                    breaks = scales::trans_breaks("log10",function(x) 10^x, n = 5),
   #                       labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  # scale_x_log10(name = "Particle Length (nm)", #expression(paste("Particle Length (", mu, "m)")),
  #               limits = c(0, 1000000),
  #               labels = scales::label_comma()
  #               ) +#,
scale_x_log10() +
  #n.breaks = 10) +
  scale_y_continuous(name = "Particle Translocation Probability",
                     labels = scales::percent, limits = c(0,1)) +
  # labs(title = "Microplastics Particle Translocation",
  #      subtitle = "General Linear Model Output",
  #      caption = "p = 0.034, RMSE = 0.54") +
  #geom_smooth() +
  #scale_color_gradientn(colors = topo.colors(7)) +
  #scale_color_viridis_c(option = "A") +
  theme_bw()
  #dark_theme_bw()
translocation_glm
```





### Model comparison
```{r}
library(jtools)
library(huxtable)
library(flextable)
simple <- lm(translocated_10 ~ size.um, data = df, family = "binomial")
m2 <- lm(translocated_10 ~ Shape, data = df, family = "binomial")
m3 <- lm(translocated_10 ~ Polymer, data = df, family = "binomial")
m4 <- lm(translocated_10 ~ Shape + size.um, data = df, family = "binomial")
m5 <- lm(translocated_10 ~ Shape + size.um + Polymer, data = df, family = "binomial")
m6 <- lm(translocated_10 ~ Shape +  Polymer, data = df, family = "binomial")
full <- glm(translocated_10~., data = df, family = "binomial")


export_summs(simple, m2, m3, m4, scale = TRUE)
```


```{r}
step <- step(full, direction = "both")
summary(step)

```

```{r}
simple <- glm(translocated_10 ~ size.um, data = df, family = "binomial")
simple_summary <- summary(simple)
simple_summary
```


# Final approach for MC modelling
Estimation of the 50% Probability Threshold
The 50% probability threshold for the predictor variable size.um was calculated using the logistic regression coefficients. The threshold corresponds to the value of size.um at which the predicted probability of translocated_10 equals 0.5. Mathematically, this threshold is determined by solving the equation:

logit(0.5) =ð›½0 +ð›½1 Ã— size.um

where ð›½0  is the intercept and ð›½1 is the slope coefficient from the fitted model.

## Bootstrap Simulation
To account for model variability and provide a more robust estimate of the size.um distribution at the 50% probability threshold, a bootstrap approach was employed. The following steps were undertaken:

Bootstrap Resampling: The dataset was resampled with replacement 1000 times.
Model Refitting: For each bootstrap sample, the logistic regression model was refitted, and the 50% probability threshold for size.um was recalculated.
Distribution Analysis: The distribution of the recalculated size.um thresholds across all bootstrap samples was analyzed to assess the variability and confidence intervals.
The bootstrap procedure was implemented using the boot package in R. The specific steps and R code are detailed below:

Define the function to calculate the size.um threshold for a bootstrap sample:


Perform the bootstrap resampling and threshold calculation:
```{r}
tissue_threshold_fun <- function(data, indices) {
  d <- data[indices, ]
  fit <- glm(translocated_10 ~ size.um, family = "binomial", data = d)
  intercept <- coef(fit)[1]
  slope <- coef(fit)[2]
  threshold <- -intercept / slope
  # Ensure the threshold is non-negative
  if (threshold < 0) threshold <- NA
  return(threshold)
}
```


```{r message=FALSE, warning=FALSE, include=FALSE}
library(boot)
set.seed(123)  # For reproducibility
bootstrap_results <- boot(data = df, statistic = tissue_threshold_fun, R = 1000)
```

Extract and analyze the bootstrap estimates:

```{r}
bootstrap_thresholds <- bootstrap_results$t
```

```{r}
summary(bootstrap_thresholds)
```

Visualize the distribution of bootstrap estimates:

```{r}
library(ggplot2)
df_bootstrap <- data.frame(size_um = bootstrap_thresholds)
ggplot(df_bootstrap, aes(x = size_um)) +
  geom_histogram(bins = 100, color = "black", fill = "skyblue", alpha = 0.7) +
  geom_vline(xintercept = mean(bootstrap_thresholds), linetype = "dashed", color = "red") +
  scale_x_log10() +
  labs(title = "Bootstrap Distribution of size.um around 50% Probability",
       x = "size.um at 50% Probability", y = "Frequency") +
  theme_minimal()
```


Results Interpretation
The bootstrap simulation provides a distribution of size.um values at the 50% probability threshold, accounting for model variability. The histogram of the bootstrap estimates, along with a vertical dashed line indicating the mean of these estimates, offers insights into the central tendency and spread of the size.um values associated with a 50% predicted probability of the outcome.

By employing this robust bootstrap method, we capture the inherent variability in the model estimation process, leading to more reliable and interpretable results regarding the predictor's effect at the specified probability threshold.


Fit the GLM model: (already done)
Bootstrap the data: Resample the data multiple times.
Refit the GLM model for each bootstrap sample: Calculate the 50% probability threshold for each.
Simulate the distribution of size.um values: Use the results from the bootstrap samples.

```{r}
library(boot)
library(ggplot2)

# Define the function to calculate the size.um at 50% probability for a bootstrap sample
threshold_fun <- function(data, indices) {
  d <- data[indices, ]
  fit <- glm(translocated_10 ~ size.um, family = "binomial", data = d)
  intercept <- coef(fit)[1]
  slope <- coef(fit)[2]
  -intercept / slope
}

# Bootstrap the data
set.seed(123) # For reproducibility
bootstrap_results <- boot(data = df, statistic = threshold_fun, R = 1000)

# Extract bootstrap estimates of the threshold size.um
bootstrap_thresholds <- bootstrap_results$t

# Plot the distribution of the bootstrap estimates
df_bootstrap <- data.frame(size_um = bootstrap_thresholds)

ggplot(df_bootstrap, aes(x = size_um)) +
  geom_histogram(bins = 40, color = "black", fill = "skyblue", alpha = 0.7) +
  geom_vline(xintercept = mean(bootstrap_thresholds), linetype = "dashed", color = "red") +
  scale_x_log10() +
  labs(title = "Bootstrap Distribution of size.um around 50% Probability",
       x = "size.um at 50% Probability", y = "Frequency") +
  theme_minimal()


```



Obtain standard error around 50th percentile probhabilty prediction for particle length

The variability (standard error) of probability estimates derived from a logistic regression model can be calculated using the delta method:

The delta method is a technique for approximating the standard error of a function of a random variable (in this case, the logistic function of the estimated parameters). You can use it to approximate the standard error of **P** at a given **X**:

Calculate the variance-covariance matrix of the logistic regression coefficients (letâ€™s denote this matrix as Î£).

The variance of \( P \) can be approximated by the formula:

\[
\text{Var}(P) \approx \left( \frac{\partial P}{\partial \beta} \right)^T \Sigma \left( \frac{\partial P}{\partial \beta} \right)
\]

where:
- \( \frac{\partial P}{\partial \beta} \) is the gradient of \( P \) with respect to the logistic regression coefficients \( \beta \).
- \( \Sigma \) is the variance-covariance matrix of the logistic regression coefficients.
- The superscript \( T \) denotes the transpose of the vector.

The gradient \( \frac{\partial P}{\partial \beta} \) can be calculated as:

\[
\frac{\partial P}{\partial \beta} = \begin{bmatrix} P(1-P) \\ X_{50}P(1-P) \end{bmatrix}
\]

where:
- \( P \) is the probability of the outcome at \( X_{50} \), the median or specified value of the predictor.
- \( X_{50} \) represents the median or specific value of the predictor variable for which you want to calculate the gradient.

```{r}
# Calculate predicted probabilities at X50
X50 <- 83  #um
P50 <- predict(simple, newdata = data.frame(size.um = X50), type = "response")

# Calculate the gradient
P <- P50
gradient <- c(P * (1 - P), X50 * P * (1 - P))

# Get variance-covariance matrix of the coefficient estimates
vcov_matrix <- vcov(simple)

# Calculate variance of P
var_P <- t(gradient) %*% vcov_matrix %*% gradient

# Standard error of P
SE_P <- sqrt(var_P)

paste("50th percentile translocation standard error:",
      (SE_P))

```

```{r}
# Number of simulations
n_sim <- 1000

# Simulate the probabilities around P50
simulated_probabilities <- rnorm(n_sim, mean = X50, sd = SE_P)

# Ensure probabilities are within the range [0, 1]
simulated_probabilities <- pmax(pmin(simulated_probabilities, 1), 0)

# View the summary of these simulations
summary(simulated_probabilities)

# Plotting the distribution of simulated probabilities
library(ggplot2)
ggplot(data = data.frame(SimulatedProb = simulated_probabilities), aes(x = SimulatedProb)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "black") +
  labs(title = "Distribution of Simulated 50th Percentile Probabilities",
       x = "Simulated Probability",
       y = "Frequency")

```

```{r}
# Parameters from the logistic regression
beta_0 <- simple$coefficients[[1]]  # 1.24  # Intercept
beta_1 <- simple$coefficients[[2]]   #-0.014  # Slope for particle length
se_beta_0 <-simple_summary$coefficients[[1,2]]  # 0.40  # SE of intercept
se_beta_1 <- simple_summary$coefficients[[2,2]]  # SE of slope

# Number of simulations
n_sim <- 10000

# Simulate beta_0 and beta_1
sim_beta_0 <- rnorm(n_sim, mean = beta_0, sd = se_beta_0)
sim_beta_1 <- rnorm(n_sim, mean = beta_1, sd = se_beta_1)

# Calculate X50 for each simulation
sim_X50 <- -sim_beta_0 / sim_beta_1

#truncate distribution to not fall below 0
sim_X50_trim <- sim_X50 %>% as.data.frame() %>% filter(.>0 & .<5000)
```

```{r}
summary(sim_X50_trim)
```


```{r}
quantile(sim_X50_trim$., c(0.05,0.95))
```


```{r}
# Plotting the distribution of X50

x50_MC_hist <- ggplot(data = sim_X50_trim, aes(.)) +
  geom_histogram(bins = 200, fill = "steelblue", color = "black", linewidth = 0.10) +
  scale_x_log10()+
  xlim(c(1,1000))+
  labs(title = "Distribution of Simulated X50 Values",
       x = "Particle Length (Î¼m) of 50th Percentile Probability For Tissue Translocation",
       y = "Frequency") +
  theme_minimal(base_size = 15) +
  theme(legend.position = c(0.2, 0.85),
        legend.title = element_text(size = 16, face = "bold"),
        legend.text = element_text(size = 14),
        legend.title.align = 0.5,
        legend.text.align = 0.5,
     #   legend.box.background = element_rect(color = "black", linetype =
      #                                         "solid", size = 1),
  #legend.background = element_rect(fill = "gray90", size = 0.5, linetype =
                   #                  "solid"),  # Light gray background forlegend
        #plot.title = element_text(hjust = 0.5),     # Center the main title
  plot.title = element_blank(),
        plot.subtitle = element_text(hjust = 0.5),
        plot.caption = element_text(hjust = 0.5),   # Center the caption
        axis.title.x = element_text(hjust = 0.9, size = 10),  # Center the x-axis title
        axis.text = element_text(size = 16),
        axis.title.y = element_text(vjust = 0.5, size = 15))   # Center the y-axis title (vertically))   # Center the subtitle)


ggsave(filename = "x50_MC_hist.jpg",
       dpi = 300,
       path = "../../output/Manuscript_Figs/translocation",
       plot = x50_MC_hist, width = 5, height = 4, units = "in")

x50_MC_hist
```

